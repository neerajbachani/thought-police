"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/analysisService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/analysisService.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisService: () => (/* binding */ AnalysisService),\n/* harmony export */   analysisService: () => (/* binding */ analysisService)\n/* harmony export */ });\n/* harmony import */ var _cacheService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cacheService */ \"(app-pages-browser)/./src/lib/services/cacheService.ts\");\n/* harmony import */ var _tokenBudget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenBudget */ \"(app-pages-browser)/./src/lib/services/tokenBudget.ts\");\n\n\nclass AnalysisService {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[AnalysisService]', ...args);\n        }\n    }\n    async analyzeUser(username) {\n        let analyzerUserId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '1';\n        try {\n            var _reportData_contradictions;\n            // Validate username\n            if (!username || username.trim().length === 0) {\n                throw new Error('Username is required');\n            }\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            this.debug(\"Starting analysis for \".concat(cleanUsername, \" via server API\"));\n            // Check budget status\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n            this.debug('Budget status:', budgetStatus);\n            if (budgetStatus.isWarning) {\n                console.warn(\"Budget warning: \".concat(budgetStatus.percentage.toFixed(1), \"% used\"));\n            }\n            // Call server-side API for analysis\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: cleanUsername,\n                    verbose: this.verbose\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: 'Unknown error'\n                    }));\n                throw new Error(errorData.error || \"Analysis failed with status \".concat(response.status));\n            }\n            const reportData = await response.json();\n            // Create analysis result\n            const analysis = {\n                id: \"analysis-\".concat(Date.now(), \"-\").concat(cleanUsername),\n                targetUsername: cleanUsername,\n                analyzerUserId,\n                contradictionsFound: ((_reportData_contradictions = reportData.contradictions) === null || _reportData_contradictions === void 0 ? void 0 : _reportData_contradictions.length) || 0,\n                confidenceScore: this.calculateWeightedConfidence(reportData.contradictions || []),\n                analysisDate: new Date().toISOString(),\n                reportData,\n                status: 'completed'\n            };\n            this.debug(\"Analysis complete for \".concat(cleanUsername, \":\"), {\n                contradictionsFound: analysis.contradictionsFound,\n                weightedConfidence: analysis.confidenceScore,\n                status: analysis.status\n            });\n            return analysis;\n        } catch (error) {\n            this.debug('Analysis failed:', error);\n            // Return failed analysis with error info\n            return {\n                id: \"analysis-failed-\".concat(Date.now()),\n                targetUsername: username,\n                analyzerUserId,\n                contradictionsFound: 0,\n                confidenceScore: 0,\n                analysisDate: new Date().toISOString(),\n                reportData: {\n                    summary: \"Analysis failed: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'),\n                    contradictions: [],\n                    timeline: [],\n                    stats: {\n                        totalComments: 0,\n                        timespan: '0 days',\n                        topSubreddits: [],\n                        sentimentTrend: 0\n                    }\n                },\n                status: 'failed'\n            };\n        }\n    }\n    calculateWeightedConfidence(contradictions) {\n        if (contradictions.length === 0) return 0;\n        // Weight by recency and verification status\n        let totalWeight = 0;\n        let weightedSum = 0;\n        for (const contradiction of contradictions){\n            let weight = 1;\n            // Higher weight for verified contradictions\n            if (contradiction.verified) {\n                weight *= 1.5;\n            }\n            // Higher weight for recent contradictions\n            if (contradiction.dates && contradiction.dates.length >= 2) {\n                const dates = contradiction.dates.map((d)=>new Date(d).getTime());\n                const avgDate = (dates[0] + dates[1]) / 2;\n                const ageInDays = (Date.now() - avgDate) / (24 * 60 * 60 * 1000);\n                if (ageInDays < 30) {\n                    weight *= 1.3; // Recent contradictions are more significant\n                } else if (ageInDays > 365) {\n                    weight *= 0.8; // Older contradictions less significant\n                }\n            }\n            // Weight by confidence score\n            const confidenceScore = contradiction.confidenceScore || 50;\n            weight *= confidenceScore / 100;\n            weightedSum += confidenceScore * weight;\n            totalWeight += weight;\n        }\n        return Math.round(weightedSum / totalWeight);\n    }\n    async validateUsername(username) {\n        try {\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            const response = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    async getUserPreview(username) {\n        try {\n            var _commentsData_data_children, _commentsData_data;\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            // Get user info\n            const userResponse = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            console.log('User preview response:', userResponse, userResponse.status, userResponse.statusText);\n            if (!userResponse.ok) {\n                return {\n                    exists: false,\n                    karma: 0,\n                    accountAge: 'Unknown',\n                    recentActivity: false,\n                    estimatedComments: 0\n                };\n            }\n            const userData = await userResponse.json();\n            const user = userData.data;\n            // Get a small sample of comments to check for recent activity\n            const commentsResponse = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/comments.json?limit=5\"));\n            const commentsData = commentsResponse.ok ? await commentsResponse.json() : null;\n            const hasRecentActivity = (commentsData === null || commentsData === void 0 ? void 0 : (_commentsData_data = commentsData.data) === null || _commentsData_data === void 0 ? void 0 : (_commentsData_data_children = _commentsData_data.children) === null || _commentsData_data_children === void 0 ? void 0 : _commentsData_data_children.length) > 0;\n            const accountAge = Math.floor((Date.now() / 1000 - user.created_utc) / (24 * 60 * 60));\n            const ageString = accountAge < 30 ? \"\".concat(accountAge, \" days\") : accountAge < 365 ? \"\".concat(Math.floor(accountAge / 30), \" months\") : \"\".concat(Math.floor(accountAge / 365), \" years\");\n            // Better estimation based on karma and account age\n            const dailyKarma = user.comment_karma / Math.max(accountAge, 1);\n            const estimatedComments = Math.min(Math.max(dailyKarma * 2, 100), 8000);\n            return {\n                exists: true,\n                karma: user.total_karma || 0,\n                accountAge: ageString,\n                recentActivity: hasRecentActivity,\n                estimatedComments: Math.floor(estimatedComments)\n            };\n        } catch (error) {\n            this.debug('getUserPreview failed:', error);\n            return {\n                exists: false,\n                karma: 0,\n                accountAge: 'Unknown',\n                recentActivity: false,\n                estimatedComments: 0\n            };\n        }\n    }\n    // Enhanced cache management\n    clearUserCache(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.clearAnalysis(cleanUsername);\n    }\n    getCacheStats() {\n        return _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getStats();\n    }\n    getBudgetStats() {\n        return {\n            budget: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus(),\n            usage: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getUsageStats()\n        };\n    }\n    resetBudget() {\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.resetBudget();\n    }\n    setBudget(maxDollar) {\n        let warningThreshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 80;\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.setBudget({\n            maxDollar,\n            warningThreshold\n        });\n    }\n    // Debug and monitoring methods\n    getDebugInfo() {\n        return {\n            cache: _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getDebugInfo(),\n            budget: this.getBudgetStats(),\n            verbose: this.verbose\n        };\n    }\n    // Streaming analysis for large datasets\n    async *analyzeUserStream(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        yield {\n            stage: 'validation',\n            progress: 0\n        };\n        try {\n            // Validate user\n            const isValid = await this.validateUsername(cleanUsername);\n            if (!isValid) {\n                throw new Error('User not found');\n            }\n            yield {\n                stage: 'validation',\n                progress: 100\n            };\n            // Get user preview\n            yield {\n                stage: 'fetching',\n                progress: 0\n            };\n            const preview = await this.getUserPreview(cleanUsername);\n            yield {\n                stage: 'fetching',\n                progress: 50,\n                data: preview\n            };\n            // Perform analysis\n            yield {\n                stage: 'analyzing',\n                progress: 0\n            };\n            const analysis = await this.analyzeUser(cleanUsername);\n            yield {\n                stage: 'analyzing',\n                progress: 100,\n                data: analysis.reportData\n            };\n            // Complete\n            yield {\n                stage: 'complete',\n                progress: 100,\n                data: analysis.reportData\n            };\n        } catch (error) {\n            yield {\n                stage: 'error',\n                progress: 0,\n                data: {\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                }\n            };\n        }\n    }\n    // Batch analysis for multiple users\n    async analyzeBatch(usernames) {\n        const results = [];\n        for (const username of usernames){\n            try {\n                const analysis = await this.analyzeUser(username);\n                results.push(analysis);\n                // Add delay between analyses to respect rate limits\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n            } catch (error) {\n                this.debug(\"Batch analysis failed for \".concat(username, \":\"), error);\n            // Continue with other users even if one fails\n            }\n        }\n        return results;\n    }\n    // Get cached analysis if available\n    getCachedAnalysis(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        // This would need to be implemented based on your cache structure\n        // For now, return null to indicate no cached analysis\n        return null;\n    }\n    // Health check for the analysis service\n    async healthCheck() {\n        const services = {\n            reddit: false,\n            openrouter: false,\n            cache: true // Cache is always available locally\n        };\n        // Test Reddit API\n        try {\n            const response = await fetch('/api/reddit/r/test.json', {\n                method: 'HEAD'\n            });\n            services.reddit = response.ok;\n        } catch (e) {\n            services.reddit = false;\n        }\n        // Test OpenRouter (would need a test endpoint)\n        try {\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: 'test',\n                    healthCheck: true\n                })\n            });\n            services.openrouter = response.status !== 500;\n        } catch (e) {\n            services.openrouter = false;\n        }\n        const budget = this.getBudgetStats();\n        const healthyServices = Object.values(services).filter(Boolean).length;\n        let status;\n        if (healthyServices === 3) {\n            status = 'healthy';\n        } else if (healthyServices >= 2) {\n            status = 'degraded';\n        } else {\n            status = 'unhealthy';\n        }\n        return {\n            status,\n            services,\n            budget\n        };\n    }\n    constructor(){\n        this.verbose = false;\n    }\n}\nconst analysisService = new AnalysisService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvYW5hbHlzaXNTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEM7QUFDRjtBQUdyQyxNQUFNRTtJQUdYQyxXQUFXQyxPQUFnQixFQUFFO1FBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVRQyxRQUFzQjtRQUFoQjtZQUFHQyxLQUFILHVCQUFjOztRQUMxQixJQUFJLElBQUksQ0FBQ0YsT0FBTyxFQUFFO1lBQ2hCRyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCRjtRQUN0QztJQUNGO0lBRUEsTUFBTUcsWUFBWUMsUUFBZ0IsRUFBbUQ7WUFBakRDLGlCQUFBQSxpRUFBeUI7UUFDM0QsSUFBSTtnQkF5Q3FCQztZQXhDdkIsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQ0YsWUFBWUEsU0FBU0csSUFBSSxHQUFHQyxNQUFNLEtBQUssR0FBRztnQkFDN0MsTUFBTSxJQUFJQyxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsZ0JBQWdCTixTQUFTRyxJQUFJLEdBQUdJLE9BQU8sQ0FBQyxRQUFRO1lBQ3RELElBQUksQ0FBQ1osS0FBSyxDQUFDLHlCQUF1QyxPQUFkVyxlQUFjO1lBRWxELHNCQUFzQjtZQUN0QixNQUFNRSxlQUFlakIscURBQVdBLENBQUNrQixlQUFlO1lBQ2hELElBQUksQ0FBQ2QsS0FBSyxDQUFDLGtCQUFrQmE7WUFFN0IsSUFBSUEsYUFBYUUsU0FBUyxFQUFFO2dCQUMxQmIsUUFBUWMsSUFBSSxDQUFDLG1CQUFzRCxPQUFuQ0gsYUFBYUksVUFBVSxDQUFDQyxPQUFPLENBQUMsSUFBRztZQUNyRTtZQUVBLG9DQUFvQztZQUNwQyxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sZ0JBQWdCO2dCQUMzQ0MsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQ25CcEIsVUFBVU07b0JBQ1ZaLFNBQVMsSUFBSSxDQUFD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WmpCLE9BQU8sS0FBSyxvQ0FBb0M7UUFDbEQ7UUFFQSxrQkFBa0I7UUFDbEIsSUFBSTtZQUNGLE1BQU1uRixXQUFXLE1BQU1DLE1BQU0sMkJBQTJCO2dCQUFFQyxRQUFRO1lBQU87WUFDekVnRyxTQUFTQyxNQUFNLEdBQUduRyxTQUFTTyxFQUFFO1FBQy9CLEVBQUUsVUFBTTtZQUNOMkYsU0FBU0MsTUFBTSxHQUFHO1FBQ3BCO1FBRUEsK0NBQStDO1FBQy9DLElBQUk7WUFDRixNQUFNbkcsV0FBVyxNQUFNQyxNQUFNLGdCQUFnQjtnQkFDM0NDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRXBCLFVBQVU7b0JBQVErRyxhQUFhO2dCQUFLO1lBQzdEO1lBQ0FDLFNBQVNFLFVBQVUsR0FBR3BHLFNBQVNZLE1BQU0sS0FBSztRQUM1QyxFQUFFLFVBQU07WUFDTnNGLFNBQVNFLFVBQVUsR0FBRztRQUN4QjtRQUVBLE1BQU16QixTQUFTLElBQUksQ0FBQ0QsY0FBYztRQUNsQyxNQUFNMkIsa0JBQWtCQyxPQUFPQyxNQUFNLENBQUNMLFVBQVVNLE1BQU0sQ0FBQ0MsU0FBU25ILE1BQU07UUFFdEUsSUFBSXNCO1FBQ0osSUFBSXlGLG9CQUFvQixHQUFHO1lBQ3pCekYsU0FBUztRQUNYLE9BQU8sSUFBSXlGLG1CQUFtQixHQUFHO1lBQy9CekYsU0FBUztRQUNYLE9BQU87WUFDTEEsU0FBUztRQUNYO1FBRUEsT0FBTztZQUNMQTtZQUNBc0Y7WUFDQXZCO1FBQ0Y7SUFDRjs7YUFyV1EvRixVQUFVOztBQXNXcEI7QUFFTyxNQUFNOEgsa0JBQWtCLElBQUloSSxrQkFBa0IiLCJzb3VyY2VzIjpbIkQ6XFxjb2RpbmdcXG9wZW4tc291cmNlXFx0aG91Z2h0LXBvbGljZVxcc3JjXFxsaWJcXHNlcnZpY2VzXFxhbmFseXNpc1NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9jYWNoZVNlcnZpY2UnO1xyXG5pbXBvcnQgeyB0b2tlbkJ1ZGdldCB9IGZyb20gJy4vdG9rZW5CdWRnZXQnO1xyXG5pbXBvcnQgeyBBbmFseXNpcyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBBbmFseXNpc1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgdmVyYm9zZSA9IGZhbHNlO1xyXG5cclxuICBzZXRWZXJib3NlKHZlcmJvc2U6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQW5hbHlzaXNTZXJ2aWNlXScsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVVzZXIodXNlcm5hbWU6IHN0cmluZywgYW5hbHl6ZXJVc2VySWQ6IHN0cmluZyA9ICcxJyk6IFByb21pc2U8QW5hbHlzaXM+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJuYW1lXHJcbiAgICAgIGlmICghdXNlcm5hbWUgfHwgdXNlcm5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlcm5hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgICAgdGhpcy5kZWJ1ZyhgU3RhcnRpbmcgYW5hbHlzaXMgZm9yICR7Y2xlYW5Vc2VybmFtZX0gdmlhIHNlcnZlciBBUElgKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGJ1ZGdldCBzdGF0dXNcclxuICAgICAgY29uc3QgYnVkZ2V0U3RhdHVzID0gdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCk7XHJcbiAgICAgIHRoaXMuZGVidWcoJ0J1ZGdldCBzdGF0dXM6JywgYnVkZ2V0U3RhdHVzKTtcclxuXHJcbiAgICAgIGlmIChidWRnZXRTdGF0dXMuaXNXYXJuaW5nKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBCdWRnZXQgd2FybmluZzogJHtidWRnZXRTdGF0dXMucGVyY2VudGFnZS50b0ZpeGVkKDEpfSUgdXNlZGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxsIHNlcnZlci1zaWRlIEFQSSBmb3IgYW5hbHlzaXNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hbmFseXplJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxyXG4gICAgICAgICAgdXNlcm5hbWU6IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBlcnJvcjogJ1Vua25vd24gZXJyb3InIH0pKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBBbmFseXNpcyBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlcG9ydERhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgYW5hbHlzaXMgcmVzdWx0XHJcbiAgICAgIGNvbnN0IGFuYWx5c2lzOiBBbmFseXNpcyA9IHtcclxuICAgICAgICBpZDogYGFuYWx5c2lzLSR7RGF0ZS5ub3coKX0tJHtjbGVhblVzZXJuYW1lfWAsXHJcbiAgICAgICAgdGFyZ2V0VXNlcm5hbWU6IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgYW5hbHl6ZXJVc2VySWQsXHJcbiAgICAgICAgY29udHJhZGljdGlvbnNGb3VuZDogcmVwb3J0RGF0YS5jb250cmFkaWN0aW9ucz8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiB0aGlzLmNhbGN1bGF0ZVdlaWdodGVkQ29uZmlkZW5jZShyZXBvcnREYXRhLmNvbnRyYWRpY3Rpb25zIHx8IFtdKSxcclxuICAgICAgICBhbmFseXNpc0RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICByZXBvcnREYXRhLFxyXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCdcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZGVidWcoYEFuYWx5c2lzIGNvbXBsZXRlIGZvciAke2NsZWFuVXNlcm5hbWV9OmAsIHtcclxuICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiBhbmFseXNpcy5jb250cmFkaWN0aW9uc0ZvdW5kLFxyXG4gICAgICAgIHdlaWdodGVkQ29uZmlkZW5jZTogYW5hbHlzaXMuY29uZmlkZW5jZVNjb3JlLFxyXG4gICAgICAgIHN0YXR1czogYW5hbHlzaXMuc3RhdHVzXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuZGVidWcoJ0FuYWx5c2lzIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXR1cm4gZmFpbGVkIGFuYWx5c2lzIHdpdGggZXJyb3IgaW5mb1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBgYW5hbHlzaXMtZmFpbGVkLSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgIHRhcmdldFVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICBhbmFseXplclVzZXJJZCxcclxuICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiAwLFxyXG4gICAgICAgIGNvbmZpZGVuY2VTY29yZTogMCxcclxuICAgICAgICBhbmFseXNpc0RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICByZXBvcnREYXRhOiB7XHJcbiAgICAgICAgICBzdW1tYXJ5OiBgQW5hbHlzaXMgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnfWAsXHJcbiAgICAgICAgICBjb250cmFkaWN0aW9uczogW10sXHJcbiAgICAgICAgICB0aW1lbGluZTogW10sXHJcbiAgICAgICAgICBzdGF0czoge1xyXG4gICAgICAgICAgICB0b3RhbENvbW1lbnRzOiAwLFxyXG4gICAgICAgICAgICB0aW1lc3BhbjogJzAgZGF5cycsXHJcbiAgICAgICAgICAgIHRvcFN1YnJlZGRpdHM6IFtdLFxyXG4gICAgICAgICAgICBzZW50aW1lbnRUcmVuZDogMFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhdHVzOiAnZmFpbGVkJ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVXZWlnaHRlZENvbmZpZGVuY2UoY29udHJhZGljdGlvbnM6IGFueVtdKTogbnVtYmVyIHtcclxuICAgIGlmIChjb250cmFkaWN0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG5cclxuICAgIC8vIFdlaWdodCBieSByZWNlbmN5IGFuZCB2ZXJpZmljYXRpb24gc3RhdHVzXHJcbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xyXG4gICAgbGV0IHdlaWdodGVkU3VtID0gMDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvbnRyYWRpY3Rpb24gb2YgY29udHJhZGljdGlvbnMpIHtcclxuICAgICAgbGV0IHdlaWdodCA9IDE7XHJcbiAgICAgIFxyXG4gICAgICAvLyBIaWdoZXIgd2VpZ2h0IGZvciB2ZXJpZmllZCBjb250cmFkaWN0aW9uc1xyXG4gICAgICBpZiAoY29udHJhZGljdGlvbi52ZXJpZmllZCkge1xyXG4gICAgICAgIHdlaWdodCAqPSAxLjU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEhpZ2hlciB3ZWlnaHQgZm9yIHJlY2VudCBjb250cmFkaWN0aW9uc1xyXG4gICAgICBpZiAoY29udHJhZGljdGlvbi5kYXRlcyAmJiBjb250cmFkaWN0aW9uLmRhdGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZXMgPSBjb250cmFkaWN0aW9uLmRhdGVzLm1hcCgoZDogc3RyaW5nKSA9PiBuZXcgRGF0ZShkKS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGNvbnN0IGF2Z0RhdGUgPSAoZGF0ZXNbMF0gKyBkYXRlc1sxXSkgLyAyO1xyXG4gICAgICAgIGNvbnN0IGFnZUluRGF5cyA9IChEYXRlLm5vdygpIC0gYXZnRGF0ZSkgLyAoMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGFnZUluRGF5cyA8IDMwKSB7XHJcbiAgICAgICAgICB3ZWlnaHQgKj0gMS4zOyAvLyBSZWNlbnQgY29udHJhZGljdGlvbnMgYXJlIG1vcmUgc2lnbmlmaWNhbnRcclxuICAgICAgICB9IGVsc2UgaWYgKGFnZUluRGF5cyA+IDM2NSkge1xyXG4gICAgICAgICAgd2VpZ2h0ICo9IDAuODsgLy8gT2xkZXIgY29udHJhZGljdGlvbnMgbGVzcyBzaWduaWZpY2FudFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gV2VpZ2h0IGJ5IGNvbmZpZGVuY2Ugc2NvcmVcclxuICAgICAgY29uc3QgY29uZmlkZW5jZVNjb3JlID0gY29udHJhZGljdGlvbi5jb25maWRlbmNlU2NvcmUgfHwgNTA7XHJcbiAgICAgIHdlaWdodCAqPSAoY29uZmlkZW5jZVNjb3JlIC8gMTAwKTtcclxuICAgICAgXHJcbiAgICAgIHdlaWdodGVkU3VtICs9IGNvbmZpZGVuY2VTY29yZSAqIHdlaWdodDtcclxuICAgICAgdG90YWxXZWlnaHQgKz0gd2VpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLnJvdW5kKHdlaWdodGVkU3VtIC8gdG90YWxXZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdmFsaWRhdGVVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlZGRpdC91c2VyLyR7Y2xlYW5Vc2VybmFtZX0vYWJvdXQuanNvbmApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VXNlclByZXZpZXcodXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgZXhpc3RzOiBib29sZWFuO1xyXG4gICAga2FybWE6IG51bWJlcjtcclxuICAgIGFjY291bnRBZ2U6IHN0cmluZztcclxuICAgIHJlY2VudEFjdGl2aXR5OiBib29sZWFuO1xyXG4gICAgZXN0aW1hdGVkQ29tbWVudHM6IG51bWJlcjtcclxuICB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHVzZXIgaW5mb1xyXG4gICAgICBjb25zdCB1c2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWRkaXQvdXNlci8ke2NsZWFuVXNlcm5hbWV9L2Fib3V0Lmpzb25gKTtcclxuICAgICAgY29uc29sZS5sb2coJ1VzZXIgcHJldmlldyByZXNwb25zZTonLCB1c2VyUmVzcG9uc2UsIHVzZXJSZXNwb25zZS5zdGF0dXMsIHVzZXJSZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgaWYgKCF1c2VyUmVzcG9uc2Uub2spIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZXhpc3RzOiBmYWxzZSxcclxuICAgICAgICAgIGthcm1hOiAwLFxyXG4gICAgICAgICAgYWNjb3VudEFnZTogJ1Vua25vd24nLFxyXG4gICAgICAgICAgcmVjZW50QWN0aXZpdHk6IGZhbHNlLFxyXG4gICAgICAgICAgZXN0aW1hdGVkQ29tbWVudHM6IDBcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IHVzZXJSZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRGF0YS5kYXRhO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGEgc21hbGwgc2FtcGxlIG9mIGNvbW1lbnRzIHRvIGNoZWNrIGZvciByZWNlbnQgYWN0aXZpdHlcclxuICAgICAgY29uc3QgY29tbWVudHNSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlZGRpdC91c2VyLyR7Y2xlYW5Vc2VybmFtZX0vY29tbWVudHMuanNvbj9saW1pdD01YCk7XHJcbiAgICAgIGNvbnN0IGNvbW1lbnRzRGF0YSA9IGNvbW1lbnRzUmVzcG9uc2Uub2sgPyBhd2FpdCBjb21tZW50c1Jlc3BvbnNlLmpzb24oKSA6IG51bGw7XHJcbiAgICAgIGNvbnN0IGhhc1JlY2VudEFjdGl2aXR5ID0gY29tbWVudHNEYXRhPy5kYXRhPy5jaGlsZHJlbj8ubGVuZ3RoID4gMDtcclxuXHJcbiAgICAgIGNvbnN0IGFjY291bnRBZ2UgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC8gMTAwMCAtIHVzZXIuY3JlYXRlZF91dGMpIC8gKDI0ICogNjAgKiA2MCkpO1xyXG4gICAgICBjb25zdCBhZ2VTdHJpbmcgPSBhY2NvdW50QWdlIDwgMzAgPyBgJHthY2NvdW50QWdlfSBkYXlzYCA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRBZ2UgPCAzNjUgPyBgJHtNYXRoLmZsb29yKGFjY291bnRBZ2UgLyAzMCl9IG1vbnRoc2AgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICBgJHtNYXRoLmZsb29yKGFjY291bnRBZ2UgLyAzNjUpfSB5ZWFyc2A7XHJcblxyXG4gICAgICAvLyBCZXR0ZXIgZXN0aW1hdGlvbiBiYXNlZCBvbiBrYXJtYSBhbmQgYWNjb3VudCBhZ2VcclxuICAgICAgY29uc3QgZGFpbHlLYXJtYSA9IHVzZXIuY29tbWVudF9rYXJtYSAvIE1hdGgubWF4KGFjY291bnRBZ2UsIDEpO1xyXG4gICAgICBjb25zdCBlc3RpbWF0ZWRDb21tZW50cyA9IE1hdGgubWluKE1hdGgubWF4KGRhaWx5S2FybWEgKiAyLCAxMDApLCA4MDAwKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhpc3RzOiB0cnVlLFxyXG4gICAgICAgIGthcm1hOiB1c2VyLnRvdGFsX2thcm1hIHx8IDAsXHJcbiAgICAgICAgYWNjb3VudEFnZTogYWdlU3RyaW5nLFxyXG4gICAgICAgIHJlY2VudEFjdGl2aXR5OiBoYXNSZWNlbnRBY3Rpdml0eSxcclxuICAgICAgICBlc3RpbWF0ZWRDb21tZW50czogTWF0aC5mbG9vcihlc3RpbWF0ZWRDb21tZW50cylcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuZGVidWcoJ2dldFVzZXJQcmV2aWV3IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcclxuICAgICAgICBrYXJtYTogMCxcclxuICAgICAgICBhY2NvdW50QWdlOiAnVW5rbm93bicsXHJcbiAgICAgICAgcmVjZW50QWN0aXZpdHk6IGZhbHNlLFxyXG4gICAgICAgIGVzdGltYXRlZENvbW1lbnRzOiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBjYWNoZSBtYW5hZ2VtZW50XHJcbiAgY2xlYXJVc2VyQ2FjaGUodXNlcm5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgIGNhY2hlU2VydmljZS5jbGVhckFuYWx5c2lzKGNsZWFuVXNlcm5hbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2FjaGVTdGF0cygpIHtcclxuICAgIHJldHVybiBjYWNoZVNlcnZpY2UuZ2V0U3RhdHMoKTtcclxuICB9XHJcblxyXG4gIGdldEJ1ZGdldFN0YXRzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYnVkZ2V0OiB0b2tlbkJ1ZGdldC5nZXRCdWRnZXRTdGF0dXMoKSxcclxuICAgICAgdXNhZ2U6IHRva2VuQnVkZ2V0LmdldFVzYWdlU3RhdHMoKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlc2V0QnVkZ2V0KCk6IHZvaWQge1xyXG4gICAgdG9rZW5CdWRnZXQucmVzZXRCdWRnZXQoKTtcclxuICB9XHJcblxyXG4gIHNldEJ1ZGdldChtYXhEb2xsYXI6IG51bWJlciwgd2FybmluZ1RocmVzaG9sZDogbnVtYmVyID0gODApOiB2b2lkIHtcclxuICAgIHRva2VuQnVkZ2V0LnNldEJ1ZGdldCh7IG1heERvbGxhciwgd2FybmluZ1RocmVzaG9sZCB9KTtcclxuICB9XHJcblxyXG4gIC8vIERlYnVnIGFuZCBtb25pdG9yaW5nIG1ldGhvZHNcclxuICBnZXREZWJ1Z0luZm8oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjYWNoZTogY2FjaGVTZXJ2aWNlLmdldERlYnVnSW5mbygpLFxyXG4gICAgICBidWRnZXQ6IHRoaXMuZ2V0QnVkZ2V0U3RhdHMoKSxcclxuICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gU3RyZWFtaW5nIGFuYWx5c2lzIGZvciBsYXJnZSBkYXRhc2V0c1xyXG4gIGFzeW5jKiBhbmFseXplVXNlclN0cmVhbSh1c2VybmFtZTogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8e1xyXG4gICAgc3RhZ2U6IHN0cmluZztcclxuICAgIHByb2dyZXNzOiBudW1iZXI7XHJcbiAgICBkYXRhPzogYW55O1xyXG4gIH0sIHZvaWQsIHVua25vd24+IHtcclxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICBcclxuICAgIHlpZWxkIHsgc3RhZ2U6ICd2YWxpZGF0aW9uJywgcHJvZ3Jlc3M6IDAgfTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVmFsaWRhdGUgdXNlclxyXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdGhpcy52YWxpZGF0ZVVzZXJuYW1lKGNsZWFuVXNlcm5hbWUpO1xyXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGZvdW5kJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICd2YWxpZGF0aW9uJywgcHJvZ3Jlc3M6IDEwMCB9O1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHVzZXIgcHJldmlld1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnZmV0Y2hpbmcnLCBwcm9ncmVzczogMCB9O1xyXG4gICAgICBjb25zdCBwcmV2aWV3ID0gYXdhaXQgdGhpcy5nZXRVc2VyUHJldmlldyhjbGVhblVzZXJuYW1lKTtcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2ZldGNoaW5nJywgcHJvZ3Jlc3M6IDUwLCBkYXRhOiBwcmV2aWV3IH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBQZXJmb3JtIGFuYWx5c2lzXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdhbmFseXppbmcnLCBwcm9ncmVzczogMCB9O1xyXG4gICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVVzZXIoY2xlYW5Vc2VybmFtZSk7XHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdhbmFseXppbmcnLCBwcm9ncmVzczogMTAwLCBkYXRhOiBhbmFseXNpcy5yZXBvcnREYXRhIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBDb21wbGV0ZVxyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnY29tcGxldGUnLCBwcm9ncmVzczogMTAwLCBkYXRhOiBhbmFseXNpcy5yZXBvcnREYXRhIH07XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2Vycm9yJywgcHJvZ3Jlc3M6IDAsIGRhdGE6IHsgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH0gfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJhdGNoIGFuYWx5c2lzIGZvciBtdWx0aXBsZSB1c2Vyc1xyXG4gIGFzeW5jIGFuYWx5emVCYXRjaCh1c2VybmFtZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxBbmFseXNpc1tdPiB7XHJcbiAgICBjb25zdCByZXN1bHRzOiBBbmFseXNpc1tdID0gW107XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgdXNlcm5hbWUgb2YgdXNlcm5hbWVzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVVc2VyKHVzZXJuYW1lKTtcclxuICAgICAgICByZXN1bHRzLnB1c2goYW5hbHlzaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBkZWxheSBiZXR3ZWVuIGFuYWx5c2VzIHRvIHJlc3BlY3QgcmF0ZSBsaW1pdHNcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZGVidWcoYEJhdGNoIGFuYWx5c2lzIGZhaWxlZCBmb3IgJHt1c2VybmFtZX06YCwgZXJyb3IpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgdXNlcnMgZXZlbiBpZiBvbmUgZmFpbHNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIEdldCBjYWNoZWQgYW5hbHlzaXMgaWYgYXZhaWxhYmxlXHJcbiAgZ2V0Q2FjaGVkQW5hbHlzaXModXNlcm5hbWU6IHN0cmluZyk6IEFuYWx5c2lzIHwgbnVsbCB7XHJcbiAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgYmFzZWQgb24geW91ciBjYWNoZSBzdHJ1Y3R1cmVcclxuICAgIC8vIEZvciBub3csIHJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNhY2hlZCBhbmFseXNpc1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBIZWFsdGggY2hlY2sgZm9yIHRoZSBhbmFseXNpcyBzZXJ2aWNlXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7XHJcbiAgICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5JztcclxuICAgIHNlcnZpY2VzOiB7XHJcbiAgICAgIHJlZGRpdDogYm9vbGVhbjtcclxuICAgICAgb3BlbnJvdXRlcjogYm9vbGVhbjtcclxuICAgICAgY2FjaGU6IGJvb2xlYW47XHJcbiAgICB9O1xyXG4gICAgYnVkZ2V0OiBhbnk7XHJcbiAgfT4ge1xyXG4gICAgY29uc3Qgc2VydmljZXMgPSB7XHJcbiAgICAgIHJlZGRpdDogZmFsc2UsXHJcbiAgICAgIG9wZW5yb3V0ZXI6IGZhbHNlLFxyXG4gICAgICBjYWNoZTogdHJ1ZSAvLyBDYWNoZSBpcyBhbHdheXMgYXZhaWxhYmxlIGxvY2FsbHlcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGVzdCBSZWRkaXQgQVBJXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3JlZGRpdC9yL3Rlc3QuanNvbicsIHsgbWV0aG9kOiAnSEVBRCcgfSk7XHJcbiAgICAgIHNlcnZpY2VzLnJlZGRpdCA9IHJlc3BvbnNlLm9rO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHNlcnZpY2VzLnJlZGRpdCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlc3QgT3BlblJvdXRlciAod291bGQgbmVlZCBhIHRlc3QgZW5kcG9pbnQpXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2FuYWx5emUnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VybmFtZTogJ3Rlc3QnLCBoZWFsdGhDaGVjazogdHJ1ZSB9KVxyXG4gICAgICB9KTtcclxuICAgICAgc2VydmljZXMub3BlbnJvdXRlciA9IHJlc3BvbnNlLnN0YXR1cyAhPT0gNTAwO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHNlcnZpY2VzLm9wZW5yb3V0ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWRnZXQgPSB0aGlzLmdldEJ1ZGdldFN0YXRzKCk7XHJcbiAgICBjb25zdCBoZWFsdGh5U2VydmljZXMgPSBPYmplY3QudmFsdWVzKHNlcnZpY2VzKS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBsZXQgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XHJcbiAgICBpZiAoaGVhbHRoeVNlcnZpY2VzID09PSAzKSB7XHJcbiAgICAgIHN0YXR1cyA9ICdoZWFsdGh5JztcclxuICAgIH0gZWxzZSBpZiAoaGVhbHRoeVNlcnZpY2VzID49IDIpIHtcclxuICAgICAgc3RhdHVzID0gJ2RlZ3JhZGVkJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXR1cyA9ICd1bmhlYWx0aHknO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgc2VydmljZXMsXHJcbiAgICAgIGJ1ZGdldFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmFseXNpc1NlcnZpY2UgPSBuZXcgQW5hbHlzaXNTZXJ2aWNlKCk7Il0sIm5hbWVzIjpbImNhY2hlU2VydmljZSIsInRva2VuQnVkZ2V0IiwiQW5hbHlzaXNTZXJ2aWNlIiwic2V0VmVyYm9zZSIsInZlcmJvc2UiLCJkZWJ1ZyIsImFyZ3MiLCJjb25zb2xlIiwibG9nIiwiYW5hbHl6ZVVzZXIiLCJ1c2VybmFtZSIsImFuYWx5emVyVXNlcklkIiwicmVwb3J0RGF0YSIsInRyaW0iLCJsZW5ndGgiLCJFcnJvciIsImNsZWFuVXNlcm5hbWUiLCJyZXBsYWNlIiwiYnVkZ2V0U3RhdHVzIiwiZ2V0QnVkZ2V0U3RhdHVzIiwiaXNXYXJuaW5nIiwid2FybiIsInBlcmNlbnRhZ2UiLCJ0b0ZpeGVkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwiZXJyb3IiLCJzdGF0dXMiLCJhbmFseXNpcyIsImlkIiwiRGF0ZSIsIm5vdyIsInRhcmdldFVzZXJuYW1lIiwiY29udHJhZGljdGlvbnNGb3VuZCIsImNvbnRyYWRpY3Rpb25zIiwiY29uZmlkZW5jZVNjb3JlIiwiY2FsY3VsYXRlV2VpZ2h0ZWRDb25maWRlbmNlIiwiYW5hbHlzaXNEYXRlIiwidG9JU09TdHJpbmciLCJ3ZWlnaHRlZENvbmZpZGVuY2UiLCJzdW1tYXJ5IiwibWVzc2FnZSIsInRpbWVsaW5lIiwic3RhdHMiLCJ0b3RhbENvbW1lbnRzIiwidGltZXNwYW4iLCJ0b3BTdWJyZWRkaXRzIiwic2VudGltZW50VHJlbmQiLCJ0b3RhbFdlaWdodCIsIndlaWdodGVkU3VtIiwiY29udHJhZGljdGlvbiIsIndlaWdodCIsInZlcmlmaWVkIiwiZGF0ZXMiLCJtYXAiLCJkIiwiZ2V0VGltZSIsImF2Z0RhdGUiLCJhZ2VJbkRheXMiLCJNYXRoIiwicm91bmQiLCJ2YWxpZGF0ZVVzZXJuYW1lIiwiZ2V0VXNlclByZXZpZXciLCJjb21tZW50c0RhdGEiLCJ1c2VyUmVzcG9uc2UiLCJzdGF0dXNUZXh0IiwiZXhpc3RzIiwia2FybWEiLCJhY2NvdW50QWdlIiwicmVjZW50QWN0aXZpdHkiLCJlc3RpbWF0ZWRDb21tZW50cyIsInVzZXJEYXRhIiwidXNlciIsImRhdGEiLCJjb21tZW50c1Jlc3BvbnNlIiwiaGFzUmVjZW50QWN0aXZpdHkiLCJjaGlsZHJlbiIsImZsb29yIiwiY3JlYXRlZF91dGMiLCJhZ2VTdHJpbmciLCJkYWlseUthcm1hIiwiY29tbWVudF9rYXJtYSIsIm1heCIsIm1pbiIsInRvdGFsX2thcm1hIiwiY2xlYXJVc2VyQ2FjaGUiLCJjbGVhckFuYWx5c2lzIiwiZ2V0Q2FjaGVTdGF0cyIsImdldFN0YXRzIiwiZ2V0QnVkZ2V0U3RhdHMiLCJidWRnZXQiLCJ1c2FnZSIsImdldFVzYWdlU3RhdHMiLCJyZXNldEJ1ZGdldCIsInNldEJ1ZGdldCIsIm1heERvbGxhciIsIndhcm5pbmdUaHJlc2hvbGQiLCJnZXREZWJ1Z0luZm8iLCJjYWNoZSIsImFuYWx5emVVc2VyU3RyZWFtIiwic3RhZ2UiLCJwcm9ncmVzcyIsImlzVmFsaWQiLCJwcmV2aWV3IiwiYW5hbHl6ZUJhdGNoIiwidXNlcm5hbWVzIiwicmVzdWx0cyIsInB1c2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRDYWNoZWRBbmFseXNpcyIsImhlYWx0aENoZWNrIiwic2VydmljZXMiLCJyZWRkaXQiLCJvcGVucm91dGVyIiwiaGVhbHRoeVNlcnZpY2VzIiwiT2JqZWN0IiwidmFsdWVzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImFuYWx5c2lzU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/analysisService.ts\n"));

/***/ })

});