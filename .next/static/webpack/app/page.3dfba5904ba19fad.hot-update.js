"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/analysisService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/analysisService.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisService: () => (/* binding */ AnalysisService),\n/* harmony export */   analysisService: () => (/* binding */ analysisService)\n/* harmony export */ });\n/* harmony import */ var _cacheService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cacheService */ \"(app-pages-browser)/./src/lib/services/cacheService.ts\");\n/* harmony import */ var _tokenBudget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenBudget */ \"(app-pages-browser)/./src/lib/services/tokenBudget.ts\");\n\n\nclass AnalysisService {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[AnalysisService]', ...args);\n        }\n    }\n    async analyzeUser(username) {\n        let analyzerUserId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '1';\n        try {\n            var _reportData_contradictions;\n            // Validate username\n            if (!username || username.trim().length === 0) {\n                throw new Error('Username is required');\n            }\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            this.debug(\"Starting analysis for \".concat(cleanUsername, \" via server API\"));\n            // Check budget status\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n            this.debug('Budget status:', budgetStatus);\n            if (budgetStatus.isWarning) {\n                console.warn(\"Budget warning: \".concat(budgetStatus.percentage.toFixed(1), \"% used\"));\n            }\n            // Call server-side API for analysis\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: cleanUsername,\n                    verbose: this.verbose\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: 'Unknown error'\n                    }));\n                throw new Error(errorData.error || \"Analysis failed with status \".concat(response.status));\n            }\n            const reportData = await response.json();\n            // Create analysis result\n            const analysis = {\n                id: \"analysis-\".concat(Date.now(), \"-\").concat(cleanUsername),\n                targetUsername: cleanUsername,\n                analyzerUserId,\n                contradictionsFound: ((_reportData_contradictions = reportData.contradictions) === null || _reportData_contradictions === void 0 ? void 0 : _reportData_contradictions.length) || 0,\n                confidenceScore: this.calculateWeightedConfidence(reportData.contradictions || []),\n                analysisDate: new Date().toISOString(),\n                reportData,\n                status: 'completed'\n            };\n            this.debug(\"Analysis complete for \".concat(cleanUsername, \":\"), {\n                contradictionsFound: analysis.contradictionsFound,\n                weightedConfidence: analysis.confidenceScore,\n                status: analysis.status\n            });\n            return analysis;\n        } catch (error) {\n            this.debug('Analysis failed:', error);\n            // Return failed analysis with error info\n            return {\n                id: \"analysis-failed-\".concat(Date.now()),\n                targetUsername: username,\n                analyzerUserId,\n                contradictionsFound: 0,\n                confidenceScore: 0,\n                analysisDate: new Date().toISOString(),\n                reportData: {\n                    summary: \"Analysis failed: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'),\n                    contradictions: [],\n                    timeline: [],\n                    stats: {\n                        totalComments: 0,\n                        timespan: '0 days',\n                        topSubreddits: [],\n                        sentimentTrend: 0\n                    }\n                },\n                status: 'failed'\n            };\n        }\n    }\n    calculateWeightedConfidence(contradictions) {\n        if (contradictions.length === 0) return 0;\n        // Weight by recency and verification status\n        let totalWeight = 0;\n        let weightedSum = 0;\n        for (const contradiction of contradictions){\n            let weight = 1;\n            // Higher weight for verified contradictions\n            if (contradiction.verified) {\n                weight *= 1.5;\n            }\n            // Higher weight for recent contradictions\n            if (contradiction.dates && contradiction.dates.length >= 2) {\n                const dates = contradiction.dates.map((d)=>new Date(d).getTime());\n                const avgDate = (dates[0] + dates[1]) / 2;\n                const ageInDays = (Date.now() - avgDate) / (24 * 60 * 60 * 1000);\n                if (ageInDays < 30) {\n                    weight *= 1.3; // Recent contradictions are more significant\n                } else if (ageInDays > 365) {\n                    weight *= 0.8; // Older contradictions less significant\n                }\n            }\n            // Weight by confidence score\n            const confidenceScore = contradiction.confidenceScore || 50;\n            weight *= confidenceScore / 100;\n            weightedSum += confidenceScore * weight;\n            totalWeight += weight;\n        }\n        return Math.round(weightedSum / totalWeight);\n    }\n    async validateUsername(username) {\n        try {\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            const response = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    async getUserPreview(username) {\n        try {\n            var _commentsData_data_children, _commentsData_data;\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            // Get user info\n            const userResponse = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            console.log('User preview response:', userResponse);\n            if (!userResponse.ok) {\n                return {\n                    exists: false,\n                    karma: 0,\n                    accountAge: 'Unknown',\n                    recentActivity: false,\n                    estimatedComments: 0\n                };\n            }\n            const userData = await userResponse.json();\n            const user = userData.data;\n            // Get a small sample of comments to check for recent activity\n            const commentsResponse = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/comments.json?limit=5\"));\n            const commentsData = commentsResponse.ok ? await commentsResponse.json() : null;\n            const hasRecentActivity = (commentsData === null || commentsData === void 0 ? void 0 : (_commentsData_data = commentsData.data) === null || _commentsData_data === void 0 ? void 0 : (_commentsData_data_children = _commentsData_data.children) === null || _commentsData_data_children === void 0 ? void 0 : _commentsData_data_children.length) > 0;\n            const accountAge = Math.floor((Date.now() / 1000 - user.created_utc) / (24 * 60 * 60));\n            const ageString = accountAge < 30 ? \"\".concat(accountAge, \" days\") : accountAge < 365 ? \"\".concat(Math.floor(accountAge / 30), \" months\") : \"\".concat(Math.floor(accountAge / 365), \" years\");\n            // Better estimation based on karma and account age\n            const dailyKarma = user.comment_karma / Math.max(accountAge, 1);\n            const estimatedComments = Math.min(Math.max(dailyKarma * 2, 100), 8000);\n            return {\n                exists: true,\n                karma: user.total_karma || 0,\n                accountAge: ageString,\n                recentActivity: hasRecentActivity,\n                estimatedComments: Math.floor(estimatedComments)\n            };\n        } catch (error) {\n            this.debug('getUserPreview failed:', error);\n            return {\n                exists: false,\n                karma: 0,\n                accountAge: 'Unknown',\n                recentActivity: false,\n                estimatedComments: 0\n            };\n        }\n    }\n    // Enhanced cache management\n    clearUserCache(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.clearAnalysis(cleanUsername);\n    }\n    getCacheStats() {\n        return _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getStats();\n    }\n    getBudgetStats() {\n        return {\n            budget: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus(),\n            usage: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getUsageStats()\n        };\n    }\n    resetBudget() {\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.resetBudget();\n    }\n    setBudget(maxDollar) {\n        let warningThreshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 80;\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.setBudget({\n            maxDollar,\n            warningThreshold\n        });\n    }\n    // Debug and monitoring methods\n    getDebugInfo() {\n        return {\n            cache: _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getDebugInfo(),\n            budget: this.getBudgetStats(),\n            verbose: this.verbose\n        };\n    }\n    // Streaming analysis for large datasets\n    async *analyzeUserStream(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        yield {\n            stage: 'validation',\n            progress: 0\n        };\n        try {\n            // Validate user\n            const isValid = await this.validateUsername(cleanUsername);\n            if (!isValid) {\n                throw new Error('User not found');\n            }\n            yield {\n                stage: 'validation',\n                progress: 100\n            };\n            // Get user preview\n            yield {\n                stage: 'fetching',\n                progress: 0\n            };\n            const preview = await this.getUserPreview(cleanUsername);\n            yield {\n                stage: 'fetching',\n                progress: 50,\n                data: preview\n            };\n            // Perform analysis\n            yield {\n                stage: 'analyzing',\n                progress: 0\n            };\n            const analysis = await this.analyzeUser(cleanUsername);\n            yield {\n                stage: 'analyzing',\n                progress: 100,\n                data: analysis.reportData\n            };\n            // Complete\n            yield {\n                stage: 'complete',\n                progress: 100,\n                data: analysis.reportData\n            };\n        } catch (error) {\n            yield {\n                stage: 'error',\n                progress: 0,\n                data: {\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                }\n            };\n        }\n    }\n    // Batch analysis for multiple users\n    async analyzeBatch(usernames) {\n        const results = [];\n        for (const username of usernames){\n            try {\n                const analysis = await this.analyzeUser(username);\n                results.push(analysis);\n                // Add delay between analyses to respect rate limits\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n            } catch (error) {\n                this.debug(\"Batch analysis failed for \".concat(username, \":\"), error);\n            // Continue with other users even if one fails\n            }\n        }\n        return results;\n    }\n    // Get cached analysis if available\n    getCachedAnalysis(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        // This would need to be implemented based on your cache structure\n        // For now, return null to indicate no cached analysis\n        return null;\n    }\n    // Health check for the analysis service\n    async healthCheck() {\n        const services = {\n            reddit: false,\n            openrouter: false,\n            cache: true // Cache is always available locally\n        };\n        // Test Reddit API\n        try {\n            const response = await fetch('/api/reddit/r/test.json', {\n                method: 'HEAD'\n            });\n            services.reddit = response.ok;\n        } catch (e) {\n            services.reddit = false;\n        }\n        // Test OpenRouter (would need a test endpoint)\n        try {\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: 'test',\n                    healthCheck: true\n                })\n            });\n            services.openrouter = response.status !== 500;\n        } catch (e) {\n            services.openrouter = false;\n        }\n        const budget = this.getBudgetStats();\n        const healthyServices = Object.values(services).filter(Boolean).length;\n        let status;\n        if (healthyServices === 3) {\n            status = 'healthy';\n        } else if (healthyServices >= 2) {\n            status = 'degraded';\n        } else {\n            status = 'unhealthy';\n        }\n        return {\n            status,\n            services,\n            budget\n        };\n    }\n    constructor(){\n        this.verbose = false;\n    }\n}\nconst analysisService = new AnalysisService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvYW5hbHlzaXNTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEM7QUFDRjtBQUdyQyxNQUFNRTtJQUdYQyxXQUFXQyxPQUFnQixFQUFFO1FBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVRQyxRQUFzQjtRQUFoQjtZQUFHQyxLQUFILHVCQUFjOztRQUMxQixJQUFJLElBQUksQ0FBQ0YsT0FBTyxFQUFFO1lBQ2hCRyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCRjtRQUN0QztJQUNGO0lBRUEsTUFBTUcsWUFBWUMsUUFBZ0IsRUFBbUQ7WUFBakRDLGlCQUFBQSxpRUFBeUI7UUFDM0QsSUFBSTtnQkEwQ3FCQztZQXpDdkIsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQ0YsWUFBWUEsU0FBU0csSUFBSSxHQUFHQyxNQUFNLEtBQUssR0FBRztnQkFDN0MsTUFBTSxJQUFJQyxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsZ0JBQWdCTixTQUFTRyxJQUFJLEdBQUdJLE9BQU8sQ0FBQyxRQUFRO1lBQ3RELElBQUksQ0FBQ1osS0FBSyxDQUFDLHlCQUF1QyxPQUFkVyxlQUFjO1lBRWxELHNCQUFzQjtZQUN0QixNQUFNRSxlQUFlakIscURBQVdBLENBQUNrQixlQUFlO1lBQ2hELElBQUksQ0FBQ2QsS0FBSyxDQUFDLGtCQUFrQmE7WUFFN0IsSUFBSUEsYUFBYUUsU0FBUyxFQUFFO2dCQUMxQmIsUUFBUWMsSUFBSSxDQUFDLG1CQUFzRCxPQUFuQ0gsYUFBYUksVUFBVSxDQUFDQyxPQUFPLENBQUMsSUFBRztZQUNyRTtZQUVBLG9DQUFvQztZQUNwQyxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sZ0JBQWdCO2dCQUMzQ0MsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBRWxCO2dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQ25CcEIsVUFBVU07b0JBQ1ZaLFNBQVMsSUFBSSxDQUFD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a0I7UUFDbEIsSUFBSTtZQUNGLE1BQU1sRixXQUFXLE1BQU1DLE1BQU0sMkJBQTJCO2dCQUFFQyxRQUFRO1lBQU87WUFDekUrRixTQUFTQyxNQUFNLEdBQUdsRyxTQUFTTyxFQUFFO1FBQy9CLEVBQUUsVUFBTTtZQUNOMEYsU0FBU0MsTUFBTSxHQUFHO1FBQ3BCO1FBRUEsK0NBQStDO1FBQy9DLElBQUk7WUFDRixNQUFNbEcsV0FBVyxNQUFNQyxNQUFNLGdCQUFnQjtnQkFDM0NDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRXBCLFVBQVU7b0JBQVE4RyxhQUFhO2dCQUFLO1lBQzdEO1lBQ0FDLFNBQVNFLFVBQVUsR0FBR25HLFNBQVNZLE1BQU0sS0FBSztRQUM1QyxFQUFFLFVBQU07WUFDTnFGLFNBQVNFLFVBQVUsR0FBRztRQUN4QjtRQUVBLE1BQU16QixTQUFTLElBQUksQ0FBQ0QsY0FBYztRQUNsQyxNQUFNMkIsa0JBQWtCQyxPQUFPQyxNQUFNLENBQUNMLFVBQVVNLE1BQU0sQ0FBQ0MsU0FBU2xILE1BQU07UUFFdEUsSUFBSXNCO1FBQ0osSUFBSXdGLG9CQUFvQixHQUFHO1lBQ3pCeEYsU0FBUztRQUNYLE9BQU8sSUFBSXdGLG1CQUFtQixHQUFHO1lBQy9CeEYsU0FBUztRQUNYLE9BQU87WUFDTEEsU0FBUztRQUNYO1FBRUEsT0FBTztZQUNMQTtZQUNBcUY7WUFDQXZCO1FBQ0Y7SUFDRjs7YUF0V1E5RixVQUFVOztBQXVXcEI7QUFFTyxNQUFNNkgsa0JBQWtCLElBQUkvSCxrQkFBa0IiLCJzb3VyY2VzIjpbIkQ6XFxjb2RpbmdcXG9wZW4tc291cmNlXFx0aG91Z2h0LXBvbGljZVxcc3JjXFxsaWJcXHNlcnZpY2VzXFxhbmFseXNpc1NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9jYWNoZVNlcnZpY2UnO1xyXG5pbXBvcnQgeyB0b2tlbkJ1ZGdldCB9IGZyb20gJy4vdG9rZW5CdWRnZXQnO1xyXG5pbXBvcnQgeyBBbmFseXNpcyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBBbmFseXNpc1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgdmVyYm9zZSA9IGZhbHNlO1xyXG5cclxuICBzZXRWZXJib3NlKHZlcmJvc2U6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQW5hbHlzaXNTZXJ2aWNlXScsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVVzZXIodXNlcm5hbWU6IHN0cmluZywgYW5hbHl6ZXJVc2VySWQ6IHN0cmluZyA9ICcxJyk6IFByb21pc2U8QW5hbHlzaXM+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJuYW1lXHJcbiAgICAgIGlmICghdXNlcm5hbWUgfHwgdXNlcm5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlcm5hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgICAgdGhpcy5kZWJ1ZyhgU3RhcnRpbmcgYW5hbHlzaXMgZm9yICR7Y2xlYW5Vc2VybmFtZX0gdmlhIHNlcnZlciBBUElgKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGJ1ZGdldCBzdGF0dXNcclxuICAgICAgY29uc3QgYnVkZ2V0U3RhdHVzID0gdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCk7XHJcbiAgICAgIHRoaXMuZGVidWcoJ0J1ZGdldCBzdGF0dXM6JywgYnVkZ2V0U3RhdHVzKTtcclxuXHJcbiAgICAgIGlmIChidWRnZXRTdGF0dXMuaXNXYXJuaW5nKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBCdWRnZXQgd2FybmluZzogJHtidWRnZXRTdGF0dXMucGVyY2VudGFnZS50b0ZpeGVkKDEpfSUgdXNlZGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxsIHNlcnZlci1zaWRlIEFQSSBmb3IgYW5hbHlzaXNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hbmFseXplJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgICBcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXHJcbiAgICAgICAgICB1c2VybmFtZTogY2xlYW5Vc2VybmFtZSxcclxuICAgICAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZSBcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGVycm9yOiAnVW5rbm93biBlcnJvcicgfSkpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYEFuYWx5c2lzIGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVwb3J0RGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSBhbmFseXNpcyByZXN1bHRcclxuICAgICAgY29uc3QgYW5hbHlzaXM6IEFuYWx5c2lzID0ge1xyXG4gICAgICAgIGlkOiBgYW5hbHlzaXMtJHtEYXRlLm5vdygpfS0ke2NsZWFuVXNlcm5hbWV9YCxcclxuICAgICAgICB0YXJnZXRVc2VybmFtZTogY2xlYW5Vc2VybmFtZSxcclxuICAgICAgICBhbmFseXplclVzZXJJZCxcclxuICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiByZXBvcnREYXRhLmNvbnRyYWRpY3Rpb25zPy5sZW5ndGggfHwgMCxcclxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IHRoaXMuY2FsY3VsYXRlV2VpZ2h0ZWRDb25maWRlbmNlKHJlcG9ydERhdGEuY29udHJhZGljdGlvbnMgfHwgW10pLFxyXG4gICAgICAgIGFuYWx5c2lzRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHJlcG9ydERhdGEsXHJcbiAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJ1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5kZWJ1ZyhgQW5hbHlzaXMgY29tcGxldGUgZm9yICR7Y2xlYW5Vc2VybmFtZX06YCwge1xyXG4gICAgICAgIGNvbnRyYWRpY3Rpb25zRm91bmQ6IGFuYWx5c2lzLmNvbnRyYWRpY3Rpb25zRm91bmQsXHJcbiAgICAgICAgd2VpZ2h0ZWRDb25maWRlbmNlOiBhbmFseXNpcy5jb25maWRlbmNlU2NvcmUsXHJcbiAgICAgICAgc3RhdHVzOiBhbmFseXNpcy5zdGF0dXNcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gYW5hbHlzaXM7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5kZWJ1ZygnQW5hbHlzaXMgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJldHVybiBmYWlsZWQgYW5hbHlzaXMgd2l0aCBlcnJvciBpbmZvXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGBhbmFseXNpcy1mYWlsZWQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgdGFyZ2V0VXNlcm5hbWU6IHVzZXJuYW1lLFxyXG4gICAgICAgIGFuYWx5emVyVXNlcklkLFxyXG4gICAgICAgIGNvbnRyYWRpY3Rpb25zRm91bmQ6IDAsXHJcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiAwLFxyXG4gICAgICAgIGFuYWx5c2lzRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHJlcG9ydERhdGE6IHtcclxuICAgICAgICAgIHN1bW1hcnk6IGBBbmFseXNpcyBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCd9YCxcclxuICAgICAgICAgIGNvbnRyYWRpY3Rpb25zOiBbXSxcclxuICAgICAgICAgIHRpbWVsaW5lOiBbXSxcclxuICAgICAgICAgIHN0YXRzOiB7XHJcbiAgICAgICAgICAgIHRvdGFsQ29tbWVudHM6IDAsXHJcbiAgICAgICAgICAgIHRpbWVzcGFuOiAnMCBkYXlzJyxcclxuICAgICAgICAgICAgdG9wU3VicmVkZGl0czogW10sXHJcbiAgICAgICAgICAgIHNlbnRpbWVudFRyZW5kOiAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGF0dXM6ICdmYWlsZWQnXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNhbGN1bGF0ZVdlaWdodGVkQ29uZmlkZW5jZShjb250cmFkaWN0aW9uczogYW55W10pOiBudW1iZXIge1xyXG4gICAgaWYgKGNvbnRyYWRpY3Rpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgLy8gV2VpZ2h0IGJ5IHJlY2VuY3kgYW5kIHZlcmlmaWNhdGlvbiBzdGF0dXNcclxuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XHJcbiAgICBsZXQgd2VpZ2h0ZWRTdW0gPSAwO1xyXG5cclxuICAgIGZvciAoY29uc3QgY29udHJhZGljdGlvbiBvZiBjb250cmFkaWN0aW9ucykge1xyXG4gICAgICBsZXQgd2VpZ2h0ID0gMTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhpZ2hlciB3ZWlnaHQgZm9yIHZlcmlmaWVkIGNvbnRyYWRpY3Rpb25zXHJcbiAgICAgIGlmIChjb250cmFkaWN0aW9uLnZlcmlmaWVkKSB7XHJcbiAgICAgICAgd2VpZ2h0ICo9IDEuNTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gSGlnaGVyIHdlaWdodCBmb3IgcmVjZW50IGNvbnRyYWRpY3Rpb25zXHJcbiAgICAgIGlmIChjb250cmFkaWN0aW9uLmRhdGVzICYmIGNvbnRyYWRpY3Rpb24uZGF0ZXMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICBjb25zdCBkYXRlcyA9IGNvbnRyYWRpY3Rpb24uZGF0ZXMubWFwKChkOiBzdHJpbmcpID0+IG5ldyBEYXRlKGQpLmdldFRpbWUoKSk7XHJcbiAgICAgICAgY29uc3QgYXZnRGF0ZSA9IChkYXRlc1swXSArIGRhdGVzWzFdKSAvIDI7XHJcbiAgICAgICAgY29uc3QgYWdlSW5EYXlzID0gKERhdGUubm93KCkgLSBhdmdEYXRlKSAvICgyNCAqIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoYWdlSW5EYXlzIDwgMzApIHtcclxuICAgICAgICAgIHdlaWdodCAqPSAxLjM7IC8vIFJlY2VudCBjb250cmFkaWN0aW9ucyBhcmUgbW9yZSBzaWduaWZpY2FudFxyXG4gICAgICAgIH0gZWxzZSBpZiAoYWdlSW5EYXlzID4gMzY1KSB7XHJcbiAgICAgICAgICB3ZWlnaHQgKj0gMC44OyAvLyBPbGRlciBjb250cmFkaWN0aW9ucyBsZXNzIHNpZ25pZmljYW50XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBXZWlnaHQgYnkgY29uZmlkZW5jZSBzY29yZVxyXG4gICAgICBjb25zdCBjb25maWRlbmNlU2NvcmUgPSBjb250cmFkaWN0aW9uLmNvbmZpZGVuY2VTY29yZSB8fCA1MDtcclxuICAgICAgd2VpZ2h0ICo9IChjb25maWRlbmNlU2NvcmUgLyAxMDApO1xyXG4gICAgICBcclxuICAgICAgd2VpZ2h0ZWRTdW0gKz0gY29uZmlkZW5jZVNjb3JlICogd2VpZ2h0O1xyXG4gICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQod2VpZ2h0ZWRTdW0gLyB0b3RhbFdlaWdodCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB2YWxpZGF0ZVVzZXJuYW1lKHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcmVkZGl0L3VzZXIvJHtjbGVhblVzZXJuYW1lfS9hYm91dC5qc29uYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VyUHJldmlldyh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTx7XHJcbiAgICBleGlzdHM6IGJvb2xlYW47XHJcbiAgICBrYXJtYTogbnVtYmVyO1xyXG4gICAgYWNjb3VudEFnZTogc3RyaW5nO1xyXG4gICAgcmVjZW50QWN0aXZpdHk6IGJvb2xlYW47XHJcbiAgICBlc3RpbWF0ZWRDb21tZW50czogbnVtYmVyO1xyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdXNlciBpbmZvXHJcbiAgICAgIGNvbnN0IHVzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlZGRpdC91c2VyLyR7Y2xlYW5Vc2VybmFtZX0vYWJvdXQuanNvbmApO1xyXG4gICAgICBjb25zb2xlLmxvZygnVXNlciBwcmV2aWV3IHJlc3BvbnNlOicsIHVzZXJSZXNwb25zZSk7XHJcbiAgICAgIGlmICghdXNlclJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGV4aXN0czogZmFsc2UsXHJcbiAgICAgICAgICBrYXJtYTogMCxcclxuICAgICAgICAgIGFjY291bnRBZ2U6ICdVbmtub3duJyxcclxuICAgICAgICAgIHJlY2VudEFjdGl2aXR5OiBmYWxzZSxcclxuICAgICAgICAgIGVzdGltYXRlZENvbW1lbnRzOiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgdXNlckRhdGEgPSBhd2FpdCB1c2VyUmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBjb25zdCB1c2VyID0gdXNlckRhdGEuZGF0YTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBhIHNtYWxsIHNhbXBsZSBvZiBjb21tZW50cyB0byBjaGVjayBmb3IgcmVjZW50IGFjdGl2aXR5XHJcbiAgICAgIGNvbnN0IGNvbW1lbnRzUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9yZWRkaXQvdXNlci8ke2NsZWFuVXNlcm5hbWV9L2NvbW1lbnRzLmpzb24/bGltaXQ9NWApO1xyXG4gICAgICBjb25zdCBjb21tZW50c0RhdGEgPSBjb21tZW50c1Jlc3BvbnNlLm9rID8gYXdhaXQgY29tbWVudHNSZXNwb25zZS5qc29uKCkgOiBudWxsO1xyXG4gICAgICBjb25zdCBoYXNSZWNlbnRBY3Rpdml0eSA9IGNvbW1lbnRzRGF0YT8uZGF0YT8uY2hpbGRyZW4/Lmxlbmd0aCA+IDA7XHJcblxyXG4gICAgICBjb25zdCBhY2NvdW50QWdlID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAvIDEwMDAgLSB1c2VyLmNyZWF0ZWRfdXRjKSAvICgyNCAqIDYwICogNjApKTtcclxuICAgICAgY29uc3QgYWdlU3RyaW5nID0gYWNjb3VudEFnZSA8IDMwID8gYCR7YWNjb3VudEFnZX0gZGF5c2AgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50QWdlIDwgMzY1ID8gYCR7TWF0aC5mbG9vcihhY2NvdW50QWdlIC8gMzApfSBtb250aHNgIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgYCR7TWF0aC5mbG9vcihhY2NvdW50QWdlIC8gMzY1KX0geWVhcnNgO1xyXG5cclxuICAgICAgLy8gQmV0dGVyIGVzdGltYXRpb24gYmFzZWQgb24ga2FybWEgYW5kIGFjY291bnQgYWdlXHJcbiAgICAgIGNvbnN0IGRhaWx5S2FybWEgPSB1c2VyLmNvbW1lbnRfa2FybWEgLyBNYXRoLm1heChhY2NvdW50QWdlLCAxKTtcclxuICAgICAgY29uc3QgZXN0aW1hdGVkQ29tbWVudHMgPSBNYXRoLm1pbihNYXRoLm1heChkYWlseUthcm1hICogMiwgMTAwKSwgODAwMCk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4aXN0czogdHJ1ZSxcclxuICAgICAgICBrYXJtYTogdXNlci50b3RhbF9rYXJtYSB8fCAwLFxyXG4gICAgICAgIGFjY291bnRBZ2U6IGFnZVN0cmluZyxcclxuICAgICAgICByZWNlbnRBY3Rpdml0eTogaGFzUmVjZW50QWN0aXZpdHksXHJcbiAgICAgICAgZXN0aW1hdGVkQ29tbWVudHM6IE1hdGguZmxvb3IoZXN0aW1hdGVkQ29tbWVudHMpXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmRlYnVnKCdnZXRVc2VyUHJldmlldyBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4aXN0czogZmFsc2UsXHJcbiAgICAgICAga2FybWE6IDAsXHJcbiAgICAgICAgYWNjb3VudEFnZTogJ1Vua25vd24nLFxyXG4gICAgICAgIHJlY2VudEFjdGl2aXR5OiBmYWxzZSxcclxuICAgICAgICBlc3RpbWF0ZWRDb21tZW50czogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgY2FjaGUgbWFuYWdlbWVudFxyXG4gIGNsZWFyVXNlckNhY2hlKHVzZXJuYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICBjYWNoZVNlcnZpY2UuY2xlYXJBbmFseXNpcyhjbGVhblVzZXJuYW1lKTtcclxuICB9XHJcblxyXG4gIGdldENhY2hlU3RhdHMoKSB7XHJcbiAgICByZXR1cm4gY2FjaGVTZXJ2aWNlLmdldFN0YXRzKCk7XHJcbiAgfVxyXG5cclxuICBnZXRCdWRnZXRTdGF0cygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJ1ZGdldDogdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCksXHJcbiAgICAgIHVzYWdlOiB0b2tlbkJ1ZGdldC5nZXRVc2FnZVN0YXRzKClcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXNldEJ1ZGdldCgpOiB2b2lkIHtcclxuICAgIHRva2VuQnVkZ2V0LnJlc2V0QnVkZ2V0KCk7XHJcbiAgfVxyXG5cclxuICBzZXRCdWRnZXQobWF4RG9sbGFyOiBudW1iZXIsIHdhcm5pbmdUaHJlc2hvbGQ6IG51bWJlciA9IDgwKTogdm9pZCB7XHJcbiAgICB0b2tlbkJ1ZGdldC5zZXRCdWRnZXQoeyBtYXhEb2xsYXIsIHdhcm5pbmdUaHJlc2hvbGQgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBEZWJ1ZyBhbmQgbW9uaXRvcmluZyBtZXRob2RzXHJcbiAgZ2V0RGVidWdJbmZvKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2FjaGU6IGNhY2hlU2VydmljZS5nZXREZWJ1Z0luZm8oKSxcclxuICAgICAgYnVkZ2V0OiB0aGlzLmdldEJ1ZGdldFN0YXRzKCksXHJcbiAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFN0cmVhbWluZyBhbmFseXNpcyBmb3IgbGFyZ2UgZGF0YXNldHNcclxuICBhc3luYyogYW5hbHl6ZVVzZXJTdHJlYW0odXNlcm5hbWU6IHN0cmluZyk6IEFzeW5jR2VuZXJhdG9yPHtcclxuICAgIHN0YWdlOiBzdHJpbmc7XHJcbiAgICBwcm9ncmVzczogbnVtYmVyO1xyXG4gICAgZGF0YT86IGFueTtcclxuICB9LCB2b2lkLCB1bmtub3duPiB7XHJcbiAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgXHJcbiAgICB5aWVsZCB7IHN0YWdlOiAndmFsaWRhdGlvbicsIHByb2dyZXNzOiAwIH07XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJcclxuICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVVc2VybmFtZShjbGVhblVzZXJuYW1lKTtcclxuICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAndmFsaWRhdGlvbicsIHByb2dyZXNzOiAxMDAgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCB1c2VyIHByZXZpZXdcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2ZldGNoaW5nJywgcHJvZ3Jlc3M6IDAgfTtcclxuICAgICAgY29uc3QgcHJldmlldyA9IGF3YWl0IHRoaXMuZ2V0VXNlclByZXZpZXcoY2xlYW5Vc2VybmFtZSk7XHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdmZXRjaGluZycsIHByb2dyZXNzOiA1MCwgZGF0YTogcHJldmlldyB9O1xyXG4gICAgICBcclxuICAgICAgLy8gUGVyZm9ybSBhbmFseXNpc1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnYW5hbHl6aW5nJywgcHJvZ3Jlc3M6IDAgfTtcclxuICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVVc2VyKGNsZWFuVXNlcm5hbWUpO1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnYW5hbHl6aW5nJywgcHJvZ3Jlc3M6IDEwMCwgZGF0YTogYW5hbHlzaXMucmVwb3J0RGF0YSB9O1xyXG4gICAgICBcclxuICAgICAgLy8gQ29tcGxldGVcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2NvbXBsZXRlJywgcHJvZ3Jlc3M6IDEwMCwgZGF0YTogYW5hbHlzaXMucmVwb3J0RGF0YSB9O1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdlcnJvcicsIHByb2dyZXNzOiAwLCBkYXRhOiB7IGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9IH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBCYXRjaCBhbmFseXNpcyBmb3IgbXVsdGlwbGUgdXNlcnNcclxuICBhc3luYyBhbmFseXplQmF0Y2godXNlcm5hbWVzOiBzdHJpbmdbXSk6IFByb21pc2U8QW5hbHlzaXNbXT4ge1xyXG4gICAgY29uc3QgcmVzdWx0czogQW5hbHlzaXNbXSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IHVzZXJuYW1lIG9mIHVzZXJuYW1lcykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgdGhpcy5hbmFseXplVXNlcih1c2VybmFtZSk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKGFuYWx5c2lzKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgZGVsYXkgYmV0d2VlbiBhbmFseXNlcyB0byByZXNwZWN0IHJhdGUgbGltaXRzXHJcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmRlYnVnKGBCYXRjaCBhbmFseXNpcyBmYWlsZWQgZm9yICR7dXNlcm5hbWV9OmAsIGVycm9yKTtcclxuICAgICAgICAvLyBDb250aW51ZSB3aXRoIG90aGVyIHVzZXJzIGV2ZW4gaWYgb25lIGZhaWxzXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfVxyXG5cclxuICAvLyBHZXQgY2FjaGVkIGFuYWx5c2lzIGlmIGF2YWlsYWJsZVxyXG4gIGdldENhY2hlZEFuYWx5c2lzKHVzZXJuYW1lOiBzdHJpbmcpOiBBbmFseXNpcyB8IG51bGwge1xyXG4gICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgIFxyXG4gICAgLy8gVGhpcyB3b3VsZCBuZWVkIHRvIGJlIGltcGxlbWVudGVkIGJhc2VkIG9uIHlvdXIgY2FjaGUgc3RydWN0dXJlXHJcbiAgICAvLyBGb3Igbm93LCByZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjYWNoZWQgYW5hbHlzaXNcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLy8gSGVhbHRoIGNoZWNrIGZvciB0aGUgYW5hbHlzaXMgc2VydmljZVxyXG4gIGFzeW5jIGhlYWx0aENoZWNrKCk6IFByb21pc2U8e1xyXG4gICAgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XHJcbiAgICBzZXJ2aWNlczoge1xyXG4gICAgICByZWRkaXQ6IGJvb2xlYW47XHJcbiAgICAgIG9wZW5yb3V0ZXI6IGJvb2xlYW47XHJcbiAgICAgIGNhY2hlOiBib29sZWFuO1xyXG4gICAgfTtcclxuICAgIGJ1ZGdldDogYW55O1xyXG4gIH0+IHtcclxuICAgIGNvbnN0IHNlcnZpY2VzID0ge1xyXG4gICAgICByZWRkaXQ6IGZhbHNlLFxyXG4gICAgICBvcGVucm91dGVyOiBmYWxzZSxcclxuICAgICAgY2FjaGU6IHRydWUgLy8gQ2FjaGUgaXMgYWx3YXlzIGF2YWlsYWJsZSBsb2NhbGx5XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRlc3QgUmVkZGl0IEFQSVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9yZWRkaXQvci90ZXN0Lmpzb24nLCB7IG1ldGhvZDogJ0hFQUQnIH0pO1xyXG4gICAgICBzZXJ2aWNlcy5yZWRkaXQgPSByZXNwb25zZS5vaztcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBzZXJ2aWNlcy5yZWRkaXQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUZXN0IE9wZW5Sb3V0ZXIgKHdvdWxkIG5lZWQgYSB0ZXN0IGVuZHBvaW50KVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hbmFseXplJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWU6ICd0ZXN0JywgaGVhbHRoQ2hlY2s6IHRydWUgfSlcclxuICAgICAgfSk7XHJcbiAgICAgIHNlcnZpY2VzLm9wZW5yb3V0ZXIgPSByZXNwb25zZS5zdGF0dXMgIT09IDUwMDtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBzZXJ2aWNlcy5vcGVucm91dGVyID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYnVkZ2V0ID0gdGhpcy5nZXRCdWRnZXRTdGF0cygpO1xyXG4gICAgY29uc3QgaGVhbHRoeVNlcnZpY2VzID0gT2JqZWN0LnZhbHVlcyhzZXJ2aWNlcykuZmlsdGVyKEJvb2xlYW4pLmxlbmd0aDtcclxuICAgIFxyXG4gICAgbGV0IHN0YXR1czogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknO1xyXG4gICAgaWYgKGhlYWx0aHlTZXJ2aWNlcyA9PT0gMykge1xyXG4gICAgICBzdGF0dXMgPSAnaGVhbHRoeSc7XHJcbiAgICB9IGVsc2UgaWYgKGhlYWx0aHlTZXJ2aWNlcyA+PSAyKSB7XHJcbiAgICAgIHN0YXR1cyA9ICdkZWdyYWRlZCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGF0dXMgPSAndW5oZWFsdGh5JztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXMsXHJcbiAgICAgIHNlcnZpY2VzLFxyXG4gICAgICBidWRnZXRcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5hbHlzaXNTZXJ2aWNlID0gbmV3IEFuYWx5c2lzU2VydmljZSgpOyJdLCJuYW1lcyI6WyJjYWNoZVNlcnZpY2UiLCJ0b2tlbkJ1ZGdldCIsIkFuYWx5c2lzU2VydmljZSIsInNldFZlcmJvc2UiLCJ2ZXJib3NlIiwiZGVidWciLCJhcmdzIiwiY29uc29sZSIsImxvZyIsImFuYWx5emVVc2VyIiwidXNlcm5hbWUiLCJhbmFseXplclVzZXJJZCIsInJlcG9ydERhdGEiLCJ0cmltIiwibGVuZ3RoIiwiRXJyb3IiLCJjbGVhblVzZXJuYW1lIiwicmVwbGFjZSIsImJ1ZGdldFN0YXR1cyIsImdldEJ1ZGdldFN0YXR1cyIsImlzV2FybmluZyIsIndhcm4iLCJwZXJjZW50YWdlIiwidG9GaXhlZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsImVycm9yIiwic3RhdHVzIiwiYW5hbHlzaXMiLCJpZCIsIkRhdGUiLCJub3ciLCJ0YXJnZXRVc2VybmFtZSIsImNvbnRyYWRpY3Rpb25zRm91bmQiLCJjb250cmFkaWN0aW9ucyIsImNvbmZpZGVuY2VTY29yZSIsImNhbGN1bGF0ZVdlaWdodGVkQ29uZmlkZW5jZSIsImFuYWx5c2lzRGF0ZSIsInRvSVNPU3RyaW5nIiwid2VpZ2h0ZWRDb25maWRlbmNlIiwic3VtbWFyeSIsIm1lc3NhZ2UiLCJ0aW1lbGluZSIsInN0YXRzIiwidG90YWxDb21tZW50cyIsInRpbWVzcGFuIiwidG9wU3VicmVkZGl0cyIsInNlbnRpbWVudFRyZW5kIiwidG90YWxXZWlnaHQiLCJ3ZWlnaHRlZFN1bSIsImNvbnRyYWRpY3Rpb24iLCJ3ZWlnaHQiLCJ2ZXJpZmllZCIsImRhdGVzIiwibWFwIiwiZCIsImdldFRpbWUiLCJhdmdEYXRlIiwiYWdlSW5EYXlzIiwiTWF0aCIsInJvdW5kIiwidmFsaWRhdGVVc2VybmFtZSIsImdldFVzZXJQcmV2aWV3IiwiY29tbWVudHNEYXRhIiwidXNlclJlc3BvbnNlIiwiZXhpc3RzIiwia2FybWEiLCJhY2NvdW50QWdlIiwicmVjZW50QWN0aXZpdHkiLCJlc3RpbWF0ZWRDb21tZW50cyIsInVzZXJEYXRhIiwidXNlciIsImRhdGEiLCJjb21tZW50c1Jlc3BvbnNlIiwiaGFzUmVjZW50QWN0aXZpdHkiLCJjaGlsZHJlbiIsImZsb29yIiwiY3JlYXRlZF91dGMiLCJhZ2VTdHJpbmciLCJkYWlseUthcm1hIiwiY29tbWVudF9rYXJtYSIsIm1heCIsIm1pbiIsInRvdGFsX2thcm1hIiwiY2xlYXJVc2VyQ2FjaGUiLCJjbGVhckFuYWx5c2lzIiwiZ2V0Q2FjaGVTdGF0cyIsImdldFN0YXRzIiwiZ2V0QnVkZ2V0U3RhdHMiLCJidWRnZXQiLCJ1c2FnZSIsImdldFVzYWdlU3RhdHMiLCJyZXNldEJ1ZGdldCIsInNldEJ1ZGdldCIsIm1heERvbGxhciIsIndhcm5pbmdUaHJlc2hvbGQiLCJnZXREZWJ1Z0luZm8iLCJjYWNoZSIsImFuYWx5emVVc2VyU3RyZWFtIiwic3RhZ2UiLCJwcm9ncmVzcyIsImlzVmFsaWQiLCJwcmV2aWV3IiwiYW5hbHl6ZUJhdGNoIiwidXNlcm5hbWVzIiwicmVzdWx0cyIsInB1c2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJnZXRDYWNoZWRBbmFseXNpcyIsImhlYWx0aENoZWNrIiwic2VydmljZXMiLCJyZWRkaXQiLCJvcGVucm91dGVyIiwiaGVhbHRoeVNlcnZpY2VzIiwiT2JqZWN0IiwidmFsdWVzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImFuYWx5c2lzU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/analysisService.ts\n"));

/***/ })

});