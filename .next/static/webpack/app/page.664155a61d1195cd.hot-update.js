"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/analysisService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/analysisService.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisService: () => (/* binding */ AnalysisService),\n/* harmony export */   analysisService: () => (/* binding */ analysisService)\n/* harmony export */ });\n/* harmony import */ var _cacheService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cacheService */ \"(app-pages-browser)/./src/lib/services/cacheService.ts\");\n/* harmony import */ var _tokenBudget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenBudget */ \"(app-pages-browser)/./src/lib/services/tokenBudget.ts\");\n\n\nclass AnalysisService {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[AnalysisService]', ...args);\n        }\n    }\n    async analyzeUser(username) {\n        let analyzerUserId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '1';\n        try {\n            var _reportData_contradictions;\n            // Validate username\n            if (!username || username.trim().length === 0) {\n                throw new Error('Username is required');\n            }\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            this.debug(\"Starting analysis for \".concat(cleanUsername, \" via server API\"));\n            // Check budget status\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n            this.debug('Budget status:', budgetStatus);\n            if (budgetStatus.isWarning) {\n                console.warn(\"Budget warning: \".concat(budgetStatus.percentage.toFixed(1), \"% used\"));\n            }\n            // Call server-side API for analysis\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'HTTP-Referer':  true ? window.location.origin : 0\n                },\n                body: JSON.stringify({\n                    username: cleanUsername,\n                    verbose: this.verbose\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: 'Unknown error'\n                    }));\n                throw new Error(errorData.error || \"Analysis failed with status \".concat(response.status));\n            }\n            const reportData = await response.json();\n            // Create analysis result\n            const analysis = {\n                id: \"analysis-\".concat(Date.now(), \"-\").concat(cleanUsername),\n                targetUsername: cleanUsername,\n                analyzerUserId,\n                contradictionsFound: ((_reportData_contradictions = reportData.contradictions) === null || _reportData_contradictions === void 0 ? void 0 : _reportData_contradictions.length) || 0,\n                confidenceScore: this.calculateWeightedConfidence(reportData.contradictions || []),\n                analysisDate: new Date().toISOString(),\n                reportData,\n                status: 'completed'\n            };\n            this.debug(\"Analysis complete for \".concat(cleanUsername, \":\"), {\n                contradictionsFound: analysis.contradictionsFound,\n                weightedConfidence: analysis.confidenceScore,\n                status: analysis.status\n            });\n            return analysis;\n        } catch (error) {\n            this.debug('Analysis failed:', error);\n            // Return failed analysis with error info\n            return {\n                id: \"analysis-failed-\".concat(Date.now()),\n                targetUsername: username,\n                analyzerUserId,\n                contradictionsFound: 0,\n                confidenceScore: 0,\n                analysisDate: new Date().toISOString(),\n                reportData: {\n                    summary: \"Analysis failed: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'),\n                    contradictions: [],\n                    timeline: [],\n                    stats: {\n                        totalComments: 0,\n                        timespan: '0 days',\n                        topSubreddits: [],\n                        sentimentTrend: 0\n                    }\n                },\n                status: 'failed'\n            };\n        }\n    }\n    calculateWeightedConfidence(contradictions) {\n        if (contradictions.length === 0) return 0;\n        // Weight by recency and verification status\n        let totalWeight = 0;\n        let weightedSum = 0;\n        for (const contradiction of contradictions){\n            let weight = 1;\n            // Higher weight for verified contradictions\n            if (contradiction.verified) {\n                weight *= 1.5;\n            }\n            // Higher weight for recent contradictions\n            if (contradiction.dates && contradiction.dates.length >= 2) {\n                const dates = contradiction.dates.map((d)=>new Date(d).getTime());\n                const avgDate = (dates[0] + dates[1]) / 2;\n                const ageInDays = (Date.now() - avgDate) / (24 * 60 * 60 * 1000);\n                if (ageInDays < 30) {\n                    weight *= 1.3; // Recent contradictions are more significant\n                } else if (ageInDays > 365) {\n                    weight *= 0.8; // Older contradictions less significant\n                }\n            }\n            // Weight by confidence score\n            const confidenceScore = contradiction.confidenceScore || 50;\n            weight *= confidenceScore / 100;\n            weightedSum += confidenceScore * weight;\n            totalWeight += weight;\n        }\n        return Math.round(weightedSum / totalWeight);\n    }\n    async validateUsername(username) {\n        try {\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            const response = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    async getUserPreview(username) {\n        try {\n            var _commentsData_data_children, _commentsData_data;\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            // Get user info\n            const userResponse = await fetch(\"https://thoughtpolice.vercel.app/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            console.log('User preview response:', userResponse);\n            if (!userResponse.ok) {\n                return {\n                    exists: false,\n                    karma: 0,\n                    accountAge: 'Unknown',\n                    recentActivity: false,\n                    estimatedComments: 0\n                };\n            }\n            const userData = await userResponse.json();\n            const user = userData.data;\n            // Get a small sample of comments to check for recent activity\n            const commentsResponse = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/comments.json?limit=5\"));\n            const commentsData = commentsResponse.ok ? await commentsResponse.json() : null;\n            const hasRecentActivity = (commentsData === null || commentsData === void 0 ? void 0 : (_commentsData_data = commentsData.data) === null || _commentsData_data === void 0 ? void 0 : (_commentsData_data_children = _commentsData_data.children) === null || _commentsData_data_children === void 0 ? void 0 : _commentsData_data_children.length) > 0;\n            const accountAge = Math.floor((Date.now() / 1000 - user.created_utc) / (24 * 60 * 60));\n            const ageString = accountAge < 30 ? \"\".concat(accountAge, \" days\") : accountAge < 365 ? \"\".concat(Math.floor(accountAge / 30), \" months\") : \"\".concat(Math.floor(accountAge / 365), \" years\");\n            // Better estimation based on karma and account age\n            const dailyKarma = user.comment_karma / Math.max(accountAge, 1);\n            const estimatedComments = Math.min(Math.max(dailyKarma * 2, 100), 8000);\n            return {\n                exists: true,\n                karma: user.total_karma || 0,\n                accountAge: ageString,\n                recentActivity: hasRecentActivity,\n                estimatedComments: Math.floor(estimatedComments)\n            };\n        } catch (error) {\n            this.debug('getUserPreview failed:', error);\n            return {\n                exists: false,\n                karma: 0,\n                accountAge: 'Unknown',\n                recentActivity: false,\n                estimatedComments: 0\n            };\n        }\n    }\n    // Enhanced cache management\n    clearUserCache(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.clearAnalysis(cleanUsername);\n    }\n    getCacheStats() {\n        return _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getStats();\n    }\n    getBudgetStats() {\n        return {\n            budget: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus(),\n            usage: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getUsageStats()\n        };\n    }\n    resetBudget() {\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.resetBudget();\n    }\n    setBudget(maxDollar) {\n        let warningThreshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 80;\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.setBudget({\n            maxDollar,\n            warningThreshold\n        });\n    }\n    // Debug and monitoring methods\n    getDebugInfo() {\n        return {\n            cache: _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getDebugInfo(),\n            budget: this.getBudgetStats(),\n            verbose: this.verbose\n        };\n    }\n    // Streaming analysis for large datasets\n    async *analyzeUserStream(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        yield {\n            stage: 'validation',\n            progress: 0\n        };\n        try {\n            // Validate user\n            const isValid = await this.validateUsername(cleanUsername);\n            if (!isValid) {\n                throw new Error('User not found');\n            }\n            yield {\n                stage: 'validation',\n                progress: 100\n            };\n            // Get user preview\n            yield {\n                stage: 'fetching',\n                progress: 0\n            };\n            const preview = await this.getUserPreview(cleanUsername);\n            yield {\n                stage: 'fetching',\n                progress: 50,\n                data: preview\n            };\n            // Perform analysis\n            yield {\n                stage: 'analyzing',\n                progress: 0\n            };\n            const analysis = await this.analyzeUser(cleanUsername);\n            yield {\n                stage: 'analyzing',\n                progress: 100,\n                data: analysis.reportData\n            };\n            // Complete\n            yield {\n                stage: 'complete',\n                progress: 100,\n                data: analysis.reportData\n            };\n        } catch (error) {\n            yield {\n                stage: 'error',\n                progress: 0,\n                data: {\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                }\n            };\n        }\n    }\n    // Batch analysis for multiple users\n    async analyzeBatch(usernames) {\n        const results = [];\n        for (const username of usernames){\n            try {\n                const analysis = await this.analyzeUser(username);\n                results.push(analysis);\n                // Add delay between analyses to respect rate limits\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n            } catch (error) {\n                this.debug(\"Batch analysis failed for \".concat(username, \":\"), error);\n            // Continue with other users even if one fails\n            }\n        }\n        return results;\n    }\n    // Get cached analysis if available\n    getCachedAnalysis(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        // This would need to be implemented based on your cache structure\n        // For now, return null to indicate no cached analysis\n        return null;\n    }\n    // Health check for the analysis service\n    async healthCheck() {\n        const services = {\n            reddit: false,\n            openrouter: false,\n            cache: true // Cache is always available locally\n        };\n        // Test Reddit API\n        try {\n            const response = await fetch('/api/reddit/r/test.json', {\n                method: 'HEAD'\n            });\n            services.reddit = response.ok;\n        } catch (e) {\n            services.reddit = false;\n        }\n        // Test OpenRouter (would need a test endpoint)\n        try {\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: 'test',\n                    healthCheck: true\n                })\n            });\n            services.openrouter = response.status !== 500;\n        } catch (e) {\n            services.openrouter = false;\n        }\n        const budget = this.getBudgetStats();\n        const healthyServices = Object.values(services).filter(Boolean).length;\n        let status;\n        if (healthyServices === 3) {\n            status = 'healthy';\n        } else if (healthyServices >= 2) {\n            status = 'degraded';\n        } else {\n            status = 'unhealthy';\n        }\n        return {\n            status,\n            services,\n            budget\n        };\n    }\n    constructor(){\n        this.verbose = false;\n    }\n}\nconst analysisService = new AnalysisService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvYW5hbHlzaXNTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEM7QUFDRjtBQUdyQyxNQUFNRTtJQUdYQyxXQUFXQyxPQUFnQixFQUFFO1FBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVRQyxRQUFzQjtRQUFoQjtZQUFHQyxLQUFILHVCQUFjOztRQUMxQixJQUFJLElBQUksQ0FBQ0YsT0FBTyxFQUFFO1lBQ2hCRyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCRjtRQUN0QztJQUNGO0lBRUEsTUFBTUcsWUFBWUMsUUFBZ0IsRUFBbUQ7WUFBakRDLGlCQUFBQSxpRUFBeUI7UUFDM0QsSUFBSTtnQkEwQ3FCQztZQXpDdkIsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQ0YsWUFBWUEsU0FBU0csSUFBSSxHQUFHQyxNQUFNLEtBQUssR0FBRztnQkFDN0MsTUFBTSxJQUFJQyxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsZ0JBQWdCTixTQUFTRyxJQUFJLEdBQUdJLE9BQU8sQ0FBQyxRQUFRO1lBQ3RELElBQUksQ0FBQ1osS0FBSyxDQUFDLHlCQUF1QyxPQUFkVyxlQUFjO1lBRWxELHNCQUFzQjtZQUN0QixNQUFNRSxlQUFlakIscURBQVdBLENBQUNrQixlQUFlO1lBQ2hELElBQUksQ0FBQ2QsS0FBSyxDQUFDLGtCQUFrQmE7WUFFN0IsSUFBSUEsYUFBYUUsU0FBUyxFQUFFO2dCQUMxQmIsUUFBUWMsSUFBSSxDQUFDLG1CQUFzRCxPQUFuQ0gsYUFBYUksVUFBVSxDQUFDQyxPQUFPLENBQUMsSUFBRztZQUNyRTtZQUVBLG9DQUFvQztZQUNwQyxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sZ0JBQWdCO2dCQUMzQ0MsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGdCQUFnQixLQUE2QixHQUFHQyxPQUFPQyxRQUFRLENBQUNDLE1BQU0sR0FBRyxDQUF1QjtnQkFDbEc7Z0JBQ0FD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Q2ZDLFFBQVE7WUFDUkMsWUFBWTtZQUNaakIsT0FBTyxLQUFLLG9DQUFvQztRQUNsRDtRQUVBLGtCQUFrQjtRQUNsQixJQUFJO1lBQ0YsTUFBTXJGLFdBQVcsTUFBTUMsTUFBTSwyQkFBMkI7Z0JBQUVDLFFBQVE7WUFBTztZQUN6RWtHLFNBQVNDLE1BQU0sR0FBR3JHLFNBQVNVLEVBQUU7UUFDL0IsRUFBRSxVQUFNO1lBQ04wRixTQUFTQyxNQUFNLEdBQUc7UUFDcEI7UUFFQSwrQ0FBK0M7UUFDL0MsSUFBSTtZQUNGLE1BQU1yRyxXQUFXLE1BQU1DLE1BQU0sZ0JBQWdCO2dCQUMzQ0MsUUFBUTtnQkFDUkMsU0FBUztvQkFBRSxnQkFBZ0I7Z0JBQW1CO2dCQUM5Q0ksTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFdkIsVUFBVTtvQkFBUWlILGFBQWE7Z0JBQUs7WUFDN0Q7WUFDQUMsU0FBU0UsVUFBVSxHQUFHdEcsU0FBU2UsTUFBTSxLQUFLO1FBQzVDLEVBQUUsVUFBTTtZQUNOcUYsU0FBU0UsVUFBVSxHQUFHO1FBQ3hCO1FBRUEsTUFBTXpCLFNBQVMsSUFBSSxDQUFDRCxjQUFjO1FBQ2xDLE1BQU0yQixrQkFBa0JDLE9BQU9DLE1BQU0sQ0FBQ0wsVUFBVU0sTUFBTSxDQUFDQyxTQUFTckgsTUFBTTtRQUV0RSxJQUFJeUI7UUFDSixJQUFJd0Ysb0JBQW9CLEdBQUc7WUFDekJ4RixTQUFTO1FBQ1gsT0FBTyxJQUFJd0YsbUJBQW1CLEdBQUc7WUFDL0J4RixTQUFTO1FBQ1gsT0FBTztZQUNMQSxTQUFTO1FBQ1g7UUFFQSxPQUFPO1lBQ0xBO1lBQ0FxRjtZQUNBdkI7UUFDRjtJQUNGOzthQXRXUWpHLFVBQVU7O0FBdVdwQjtBQUVPLE1BQU1nSSxrQkFBa0IsSUFBSWxJLGtCQUFrQiIsInNvdXJjZXMiOlsiRDpcXGNvZGluZ1xcb3Blbi1zb3VyY2VcXHRob3VnaHQtcG9saWNlXFxzcmNcXGxpYlxcc2VydmljZXNcXGFuYWx5c2lzU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWNoZVNlcnZpY2UgfSBmcm9tICcuL2NhY2hlU2VydmljZSc7XHJcbmltcG9ydCB7IHRva2VuQnVkZ2V0IH0gZnJvbSAnLi90b2tlbkJ1ZGdldCc7XHJcbmltcG9ydCB7IEFuYWx5c2lzIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFuYWx5c2lzU2VydmljZSB7XHJcbiAgcHJpdmF0ZSB2ZXJib3NlID0gZmFsc2U7XHJcblxyXG4gIHNldFZlcmJvc2UodmVyYm9zZTogYm9vbGVhbikge1xyXG4gICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGVidWcoLi4uYXJnczogYW55W10pIHtcclxuICAgIGlmICh0aGlzLnZlcmJvc2UpIHtcclxuICAgICAgY29uc29sZS5sb2coJ1tBbmFseXNpc1NlcnZpY2VdJywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBhbmFseXplVXNlcih1c2VybmFtZTogc3RyaW5nLCBhbmFseXplclVzZXJJZDogc3RyaW5nID0gJzEnKTogUHJvbWlzZTxBbmFseXNpcz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVmFsaWRhdGUgdXNlcm5hbWVcclxuICAgICAgaWYgKCF1c2VybmFtZSB8fCB1c2VybmFtZS50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VybmFtZSBpcyByZXF1aXJlZCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgICB0aGlzLmRlYnVnKGBTdGFydGluZyBhbmFseXNpcyBmb3IgJHtjbGVhblVzZXJuYW1lfSB2aWEgc2VydmVyIEFQSWApO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgYnVkZ2V0IHN0YXR1c1xyXG4gICAgICBjb25zdCBidWRnZXRTdGF0dXMgPSB0b2tlbkJ1ZGdldC5nZXRCdWRnZXRTdGF0dXMoKTtcclxuICAgICAgdGhpcy5kZWJ1ZygnQnVkZ2V0IHN0YXR1czonLCBidWRnZXRTdGF0dXMpO1xyXG5cclxuICAgICAgaWYgKGJ1ZGdldFN0YXR1cy5pc1dhcm5pbmcpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYEJ1ZGdldCB3YXJuaW5nOiAke2J1ZGdldFN0YXR1cy5wZXJjZW50YWdlLnRvRml4ZWQoMSl9JSB1c2VkYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENhbGwgc2VydmVyLXNpZGUgQVBJIGZvciBhbmFseXNpc1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2FuYWx5emUnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAgICdIVFRQLVJlZmVyZXInOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXHJcbiAgICAgICAgICB1c2VybmFtZTogY2xlYW5Vc2VybmFtZSxcclxuICAgICAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZSBcclxuICAgICAgICB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7IGVycm9yOiAnVW5rbm93biBlcnJvcicgfSkpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYEFuYWx5c2lzIGZhaWxlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcmVwb3J0RGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSBhbmFseXNpcyByZXN1bHRcclxuICAgICAgY29uc3QgYW5hbHlzaXM6IEFuYWx5c2lzID0ge1xyXG4gICAgICAgIGlkOiBgYW5hbHlzaXMtJHtEYXRlLm5vdygpfS0ke2NsZWFuVXNlcm5hbWV9YCxcclxuICAgICAgICB0YXJnZXRVc2VybmFtZTogY2xlYW5Vc2VybmFtZSxcclxuICAgICAgICBhbmFseXplclVzZXJJZCxcclxuICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiByZXBvcnREYXRhLmNvbnRyYWRpY3Rpb25zPy5sZW5ndGggfHwgMCxcclxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IHRoaXMuY2FsY3VsYXRlV2VpZ2h0ZWRDb25maWRlbmNlKHJlcG9ydERhdGEuY29udHJhZGljdGlvbnMgfHwgW10pLFxyXG4gICAgICAgIGFuYWx5c2lzRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHJlcG9ydERhdGEsXHJcbiAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJ1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5kZWJ1ZyhgQW5hbHlzaXMgY29tcGxldGUgZm9yICR7Y2xlYW5Vc2VybmFtZX06YCwge1xyXG4gICAgICAgIGNvbnRyYWRpY3Rpb25zRm91bmQ6IGFuYWx5c2lzLmNvbnRyYWRpY3Rpb25zRm91bmQsXHJcbiAgICAgICAgd2VpZ2h0ZWRDb25maWRlbmNlOiBhbmFseXNpcy5jb25maWRlbmNlU2NvcmUsXHJcbiAgICAgICAgc3RhdHVzOiBhbmFseXNpcy5zdGF0dXNcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gYW5hbHlzaXM7XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5kZWJ1ZygnQW5hbHlzaXMgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFJldHVybiBmYWlsZWQgYW5hbHlzaXMgd2l0aCBlcnJvciBpbmZvXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGBhbmFseXNpcy1mYWlsZWQtJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgdGFyZ2V0VXNlcm5hbWU6IHVzZXJuYW1lLFxyXG4gICAgICAgIGFuYWx5emVyVXNlcklkLFxyXG4gICAgICAgIGNvbnRyYWRpY3Rpb25zRm91bmQ6IDAsXHJcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiAwLFxyXG4gICAgICAgIGFuYWx5c2lzRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIHJlcG9ydERhdGE6IHtcclxuICAgICAgICAgIHN1bW1hcnk6IGBBbmFseXNpcyBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCd9YCxcclxuICAgICAgICAgIGNvbnRyYWRpY3Rpb25zOiBbXSxcclxuICAgICAgICAgIHRpbWVsaW5lOiBbXSxcclxuICAgICAgICAgIHN0YXRzOiB7XHJcbiAgICAgICAgICAgIHRvdGFsQ29tbWVudHM6IDAsXHJcbiAgICAgICAgICAgIHRpbWVzcGFuOiAnMCBkYXlzJyxcclxuICAgICAgICAgICAgdG9wU3VicmVkZGl0czogW10sXHJcbiAgICAgICAgICAgIHNlbnRpbWVudFRyZW5kOiAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdGF0dXM6ICdmYWlsZWQnXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNhbGN1bGF0ZVdlaWdodGVkQ29uZmlkZW5jZShjb250cmFkaWN0aW9uczogYW55W10pOiBudW1iZXIge1xyXG4gICAgaWYgKGNvbnRyYWRpY3Rpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XHJcblxyXG4gICAgLy8gV2VpZ2h0IGJ5IHJlY2VuY3kgYW5kIHZlcmlmaWNhdGlvbiBzdGF0dXNcclxuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XHJcbiAgICBsZXQgd2VpZ2h0ZWRTdW0gPSAwO1xyXG5cclxuICAgIGZvciAoY29uc3QgY29udHJhZGljdGlvbiBvZiBjb250cmFkaWN0aW9ucykge1xyXG4gICAgICBsZXQgd2VpZ2h0ID0gMTtcclxuICAgICAgXHJcbiAgICAgIC8vIEhpZ2hlciB3ZWlnaHQgZm9yIHZlcmlmaWVkIGNvbnRyYWRpY3Rpb25zXHJcbiAgICAgIGlmIChjb250cmFkaWN0aW9uLnZlcmlmaWVkKSB7XHJcbiAgICAgICAgd2VpZ2h0ICo9IDEuNTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gSGlnaGVyIHdlaWdodCBmb3IgcmVjZW50IGNvbnRyYWRpY3Rpb25zXHJcbiAgICAgIGlmIChjb250cmFkaWN0aW9uLmRhdGVzICYmIGNvbnRyYWRpY3Rpb24uZGF0ZXMubGVuZ3RoID49IDIpIHtcclxuICAgICAgICBjb25zdCBkYXRlcyA9IGNvbnRyYWRpY3Rpb24uZGF0ZXMubWFwKChkOiBzdHJpbmcpID0+IG5ldyBEYXRlKGQpLmdldFRpbWUoKSk7XHJcbiAgICAgICAgY29uc3QgYXZnRGF0ZSA9IChkYXRlc1swXSArIGRhdGVzWzFdKSAvIDI7XHJcbiAgICAgICAgY29uc3QgYWdlSW5EYXlzID0gKERhdGUubm93KCkgLSBhdmdEYXRlKSAvICgyNCAqIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoYWdlSW5EYXlzIDwgMzApIHtcclxuICAgICAgICAgIHdlaWdodCAqPSAxLjM7IC8vIFJlY2VudCBjb250cmFkaWN0aW9ucyBhcmUgbW9yZSBzaWduaWZpY2FudFxyXG4gICAgICAgIH0gZWxzZSBpZiAoYWdlSW5EYXlzID4gMzY1KSB7XHJcbiAgICAgICAgICB3ZWlnaHQgKj0gMC44OyAvLyBPbGRlciBjb250cmFkaWN0aW9ucyBsZXNzIHNpZ25pZmljYW50XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBXZWlnaHQgYnkgY29uZmlkZW5jZSBzY29yZVxyXG4gICAgICBjb25zdCBjb25maWRlbmNlU2NvcmUgPSBjb250cmFkaWN0aW9uLmNvbmZpZGVuY2VTY29yZSB8fCA1MDtcclxuICAgICAgd2VpZ2h0ICo9IChjb25maWRlbmNlU2NvcmUgLyAxMDApO1xyXG4gICAgICBcclxuICAgICAgd2VpZ2h0ZWRTdW0gKz0gY29uZmlkZW5jZVNjb3JlICogd2VpZ2h0O1xyXG4gICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGgucm91bmQod2VpZ2h0ZWRTdW0gLyB0b3RhbFdlaWdodCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyB2YWxpZGF0ZVVzZXJuYW1lKHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcmVkZGl0L3VzZXIvJHtjbGVhblVzZXJuYW1lfS9hYm91dC5qc29uYCk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5vaztcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VyUHJldmlldyh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTx7XHJcbiAgICBleGlzdHM6IGJvb2xlYW47XHJcbiAgICBrYXJtYTogbnVtYmVyO1xyXG4gICAgYWNjb3VudEFnZTogc3RyaW5nO1xyXG4gICAgcmVjZW50QWN0aXZpdHk6IGJvb2xlYW47XHJcbiAgICBlc3RpbWF0ZWRDb21tZW50czogbnVtYmVyO1xyXG4gIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdXNlciBpbmZvXHJcbiAgICAgIGNvbnN0IHVzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL3Rob3VnaHRwb2xpY2UudmVyY2VsLmFwcC9hcGkvcmVkZGl0L3VzZXIvJHtjbGVhblVzZXJuYW1lfS9hYm91dC5qc29uYCk7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2VyIHByZXZpZXcgcmVzcG9uc2U6JywgdXNlclJlc3BvbnNlKTtcclxuICAgICAgaWYgKCF1c2VyUmVzcG9uc2Uub2spIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZXhpc3RzOiBmYWxzZSxcclxuICAgICAgICAgIGthcm1hOiAwLFxyXG4gICAgICAgICAgYWNjb3VudEFnZTogJ1Vua25vd24nLFxyXG4gICAgICAgICAgcmVjZW50QWN0aXZpdHk6IGZhbHNlLFxyXG4gICAgICAgICAgZXN0aW1hdGVkQ29tbWVudHM6IDBcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IHVzZXJSZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIGNvbnN0IHVzZXIgPSB1c2VyRGF0YS5kYXRhO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGEgc21hbGwgc2FtcGxlIG9mIGNvbW1lbnRzIHRvIGNoZWNrIGZvciByZWNlbnQgYWN0aXZpdHlcclxuICAgICAgY29uc3QgY29tbWVudHNSZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlZGRpdC91c2VyLyR7Y2xlYW5Vc2VybmFtZX0vY29tbWVudHMuanNvbj9saW1pdD01YCk7XHJcbiAgICAgIGNvbnN0IGNvbW1lbnRzRGF0YSA9IGNvbW1lbnRzUmVzcG9uc2Uub2sgPyBhd2FpdCBjb21tZW50c1Jlc3BvbnNlLmpzb24oKSA6IG51bGw7XHJcbiAgICAgIGNvbnN0IGhhc1JlY2VudEFjdGl2aXR5ID0gY29tbWVudHNEYXRhPy5kYXRhPy5jaGlsZHJlbj8ubGVuZ3RoID4gMDtcclxuXHJcbiAgICAgIGNvbnN0IGFjY291bnRBZ2UgPSBNYXRoLmZsb29yKChEYXRlLm5vdygpIC8gMTAwMCAtIHVzZXIuY3JlYXRlZF91dGMpIC8gKDI0ICogNjAgKiA2MCkpO1xyXG4gICAgICBjb25zdCBhZ2VTdHJpbmcgPSBhY2NvdW50QWdlIDwgMzAgPyBgJHthY2NvdW50QWdlfSBkYXlzYCA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRBZ2UgPCAzNjUgPyBgJHtNYXRoLmZsb29yKGFjY291bnRBZ2UgLyAzMCl9IG1vbnRoc2AgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICBgJHtNYXRoLmZsb29yKGFjY291bnRBZ2UgLyAzNjUpfSB5ZWFyc2A7XHJcblxyXG4gICAgICAvLyBCZXR0ZXIgZXN0aW1hdGlvbiBiYXNlZCBvbiBrYXJtYSBhbmQgYWNjb3VudCBhZ2VcclxuICAgICAgY29uc3QgZGFpbHlLYXJtYSA9IHVzZXIuY29tbWVudF9rYXJtYSAvIE1hdGgubWF4KGFjY291bnRBZ2UsIDEpO1xyXG4gICAgICBjb25zdCBlc3RpbWF0ZWRDb21tZW50cyA9IE1hdGgubWluKE1hdGgubWF4KGRhaWx5S2FybWEgKiAyLCAxMDApLCA4MDAwKTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhpc3RzOiB0cnVlLFxyXG4gICAgICAgIGthcm1hOiB1c2VyLnRvdGFsX2thcm1hIHx8IDAsXHJcbiAgICAgICAgYWNjb3VudEFnZTogYWdlU3RyaW5nLFxyXG4gICAgICAgIHJlY2VudEFjdGl2aXR5OiBoYXNSZWNlbnRBY3Rpdml0eSxcclxuICAgICAgICBlc3RpbWF0ZWRDb21tZW50czogTWF0aC5mbG9vcihlc3RpbWF0ZWRDb21tZW50cylcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuZGVidWcoJ2dldFVzZXJQcmV2aWV3IGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhpc3RzOiBmYWxzZSxcclxuICAgICAgICBrYXJtYTogMCxcclxuICAgICAgICBhY2NvdW50QWdlOiAnVW5rbm93bicsXHJcbiAgICAgICAgcmVjZW50QWN0aXZpdHk6IGZhbHNlLFxyXG4gICAgICAgIGVzdGltYXRlZENvbW1lbnRzOiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFbmhhbmNlZCBjYWNoZSBtYW5hZ2VtZW50XHJcbiAgY2xlYXJVc2VyQ2FjaGUodXNlcm5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgIGNhY2hlU2VydmljZS5jbGVhckFuYWx5c2lzKGNsZWFuVXNlcm5hbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q2FjaGVTdGF0cygpIHtcclxuICAgIHJldHVybiBjYWNoZVNlcnZpY2UuZ2V0U3RhdHMoKTtcclxuICB9XHJcblxyXG4gIGdldEJ1ZGdldFN0YXRzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgYnVkZ2V0OiB0b2tlbkJ1ZGdldC5nZXRCdWRnZXRTdGF0dXMoKSxcclxuICAgICAgdXNhZ2U6IHRva2VuQnVkZ2V0LmdldFVzYWdlU3RhdHMoKVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJlc2V0QnVkZ2V0KCk6IHZvaWQge1xyXG4gICAgdG9rZW5CdWRnZXQucmVzZXRCdWRnZXQoKTtcclxuICB9XHJcblxyXG4gIHNldEJ1ZGdldChtYXhEb2xsYXI6IG51bWJlciwgd2FybmluZ1RocmVzaG9sZDogbnVtYmVyID0gODApOiB2b2lkIHtcclxuICAgIHRva2VuQnVkZ2V0LnNldEJ1ZGdldCh7IG1heERvbGxhciwgd2FybmluZ1RocmVzaG9sZCB9KTtcclxuICB9XHJcblxyXG4gIC8vIERlYnVnIGFuZCBtb25pdG9yaW5nIG1ldGhvZHNcclxuICBnZXREZWJ1Z0luZm8oKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjYWNoZTogY2FjaGVTZXJ2aWNlLmdldERlYnVnSW5mbygpLFxyXG4gICAgICBidWRnZXQ6IHRoaXMuZ2V0QnVkZ2V0U3RhdHMoKSxcclxuICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NlXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gU3RyZWFtaW5nIGFuYWx5c2lzIGZvciBsYXJnZSBkYXRhc2V0c1xyXG4gIGFzeW5jKiBhbmFseXplVXNlclN0cmVhbSh1c2VybmFtZTogc3RyaW5nKTogQXN5bmNHZW5lcmF0b3I8e1xyXG4gICAgc3RhZ2U6IHN0cmluZztcclxuICAgIHByb2dyZXNzOiBudW1iZXI7XHJcbiAgICBkYXRhPzogYW55O1xyXG4gIH0sIHZvaWQsIHVua25vd24+IHtcclxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICBcclxuICAgIHlpZWxkIHsgc3RhZ2U6ICd2YWxpZGF0aW9uJywgcHJvZ3Jlc3M6IDAgfTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVmFsaWRhdGUgdXNlclxyXG4gICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgdGhpcy52YWxpZGF0ZVVzZXJuYW1lKGNsZWFuVXNlcm5hbWUpO1xyXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGZvdW5kJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICd2YWxpZGF0aW9uJywgcHJvZ3Jlc3M6IDEwMCB9O1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHVzZXIgcHJldmlld1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnZmV0Y2hpbmcnLCBwcm9ncmVzczogMCB9O1xyXG4gICAgICBjb25zdCBwcmV2aWV3ID0gYXdhaXQgdGhpcy5nZXRVc2VyUHJldmlldyhjbGVhblVzZXJuYW1lKTtcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2ZldGNoaW5nJywgcHJvZ3Jlc3M6IDUwLCBkYXRhOiBwcmV2aWV3IH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBQZXJmb3JtIGFuYWx5c2lzXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdhbmFseXppbmcnLCBwcm9ncmVzczogMCB9O1xyXG4gICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVVzZXIoY2xlYW5Vc2VybmFtZSk7XHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdhbmFseXppbmcnLCBwcm9ncmVzczogMTAwLCBkYXRhOiBhbmFseXNpcy5yZXBvcnREYXRhIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBDb21wbGV0ZVxyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnY29tcGxldGUnLCBwcm9ncmVzczogMTAwLCBkYXRhOiBhbmFseXNpcy5yZXBvcnREYXRhIH07XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2Vycm9yJywgcHJvZ3Jlc3M6IDAsIGRhdGE6IHsgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InIH0gfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEJhdGNoIGFuYWx5c2lzIGZvciBtdWx0aXBsZSB1c2Vyc1xyXG4gIGFzeW5jIGFuYWx5emVCYXRjaCh1c2VybmFtZXM6IHN0cmluZ1tdKTogUHJvbWlzZTxBbmFseXNpc1tdPiB7XHJcbiAgICBjb25zdCByZXN1bHRzOiBBbmFseXNpc1tdID0gW107XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgdXNlcm5hbWUgb2YgdXNlcm5hbWVzKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCB0aGlzLmFuYWx5emVVc2VyKHVzZXJuYW1lKTtcclxuICAgICAgICByZXN1bHRzLnB1c2goYW5hbHlzaXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBkZWxheSBiZXR3ZWVuIGFuYWx5c2VzIHRvIHJlc3BlY3QgcmF0ZSBsaW1pdHNcclxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwMCkpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZGVidWcoYEJhdGNoIGFuYWx5c2lzIGZhaWxlZCBmb3IgJHt1c2VybmFtZX06YCwgZXJyb3IpO1xyXG4gICAgICAgIC8vIENvbnRpbnVlIHdpdGggb3RoZXIgdXNlcnMgZXZlbiBpZiBvbmUgZmFpbHNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9XHJcblxyXG4gIC8vIEdldCBjYWNoZWQgYW5hbHlzaXMgaWYgYXZhaWxhYmxlXHJcbiAgZ2V0Q2FjaGVkQW5hbHlzaXModXNlcm5hbWU6IHN0cmluZyk6IEFuYWx5c2lzIHwgbnVsbCB7XHJcbiAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgXHJcbiAgICAvLyBUaGlzIHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgYmFzZWQgb24geW91ciBjYWNoZSBzdHJ1Y3R1cmVcclxuICAgIC8vIEZvciBub3csIHJldHVybiBudWxsIHRvIGluZGljYXRlIG5vIGNhY2hlZCBhbmFseXNpc1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvLyBIZWFsdGggY2hlY2sgZm9yIHRoZSBhbmFseXNpcyBzZXJ2aWNlXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7XHJcbiAgICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5JztcclxuICAgIHNlcnZpY2VzOiB7XHJcbiAgICAgIHJlZGRpdDogYm9vbGVhbjtcclxuICAgICAgb3BlbnJvdXRlcjogYm9vbGVhbjtcclxuICAgICAgY2FjaGU6IGJvb2xlYW47XHJcbiAgICB9O1xyXG4gICAgYnVkZ2V0OiBhbnk7XHJcbiAgfT4ge1xyXG4gICAgY29uc3Qgc2VydmljZXMgPSB7XHJcbiAgICAgIHJlZGRpdDogZmFsc2UsXHJcbiAgICAgIG9wZW5yb3V0ZXI6IGZhbHNlLFxyXG4gICAgICBjYWNoZTogdHJ1ZSAvLyBDYWNoZSBpcyBhbHdheXMgYXZhaWxhYmxlIGxvY2FsbHlcclxuICAgIH07XHJcblxyXG4gICAgLy8gVGVzdCBSZWRkaXQgQVBJXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3JlZGRpdC9yL3Rlc3QuanNvbicsIHsgbWV0aG9kOiAnSEVBRCcgfSk7XHJcbiAgICAgIHNlcnZpY2VzLnJlZGRpdCA9IHJlc3BvbnNlLm9rO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHNlcnZpY2VzLnJlZGRpdCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRlc3QgT3BlblJvdXRlciAod291bGQgbmVlZCBhIHRlc3QgZW5kcG9pbnQpXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2FuYWx5emUnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VybmFtZTogJ3Rlc3QnLCBoZWFsdGhDaGVjazogdHJ1ZSB9KVxyXG4gICAgICB9KTtcclxuICAgICAgc2VydmljZXMub3BlbnJvdXRlciA9IHJlc3BvbnNlLnN0YXR1cyAhPT0gNTAwO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHNlcnZpY2VzLm9wZW5yb3V0ZXIgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWRnZXQgPSB0aGlzLmdldEJ1ZGdldFN0YXRzKCk7XHJcbiAgICBjb25zdCBoZWFsdGh5U2VydmljZXMgPSBPYmplY3QudmFsdWVzKHNlcnZpY2VzKS5maWx0ZXIoQm9vbGVhbikubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBsZXQgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSc7XHJcbiAgICBpZiAoaGVhbHRoeVNlcnZpY2VzID09PSAzKSB7XHJcbiAgICAgIHN0YXR1cyA9ICdoZWFsdGh5JztcclxuICAgIH0gZWxzZSBpZiAoaGVhbHRoeVNlcnZpY2VzID49IDIpIHtcclxuICAgICAgc3RhdHVzID0gJ2RlZ3JhZGVkJztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXR1cyA9ICd1bmhlYWx0aHknO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1cyxcclxuICAgICAgc2VydmljZXMsXHJcbiAgICAgIGJ1ZGdldFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBhbmFseXNpc1NlcnZpY2UgPSBuZXcgQW5hbHlzaXNTZXJ2aWNlKCk7Il0sIm5hbWVzIjpbImNhY2hlU2VydmljZSIsInRva2VuQnVkZ2V0IiwiQW5hbHlzaXNTZXJ2aWNlIiwic2V0VmVyYm9zZSIsInZlcmJvc2UiLCJkZWJ1ZyIsImFyZ3MiLCJjb25zb2xlIiwibG9nIiwiYW5hbHl6ZVVzZXIiLCJ1c2VybmFtZSIsImFuYWx5emVyVXNlcklkIiwicmVwb3J0RGF0YSIsInRyaW0iLCJsZW5ndGgiLCJFcnJvciIsImNsZWFuVXNlcm5hbWUiLCJyZXBsYWNlIiwiYnVkZ2V0U3RhdHVzIiwiZ2V0QnVkZ2V0U3RhdHVzIiwiaXNXYXJuaW5nIiwid2FybiIsInBlcmNlbnRhZ2UiLCJ0b0ZpeGVkIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJlcnJvciIsInN0YXR1cyIsImFuYWx5c2lzIiwiaWQiLCJEYXRlIiwibm93IiwidGFyZ2V0VXNlcm5hbWUiLCJjb250cmFkaWN0aW9uc0ZvdW5kIiwiY29udHJhZGljdGlvbnMiLCJjb25maWRlbmNlU2NvcmUiLCJjYWxjdWxhdGVXZWlnaHRlZENvbmZpZGVuY2UiLCJhbmFseXNpc0RhdGUiLCJ0b0lTT1N0cmluZyIsIndlaWdodGVkQ29uZmlkZW5jZSIsInN1bW1hcnkiLCJtZXNzYWdlIiwidGltZWxpbmUiLCJzdGF0cyIsInRvdGFsQ29tbWVudHMiLCJ0aW1lc3BhbiIsInRvcFN1YnJlZGRpdHMiLCJzZW50aW1lbnRUcmVuZCIsInRvdGFsV2VpZ2h0Iiwid2VpZ2h0ZWRTdW0iLCJjb250cmFkaWN0aW9uIiwid2VpZ2h0IiwidmVyaWZpZWQiLCJkYXRlcyIsIm1hcCIsImQiLCJnZXRUaW1lIiwiYXZnRGF0ZSIsImFnZUluRGF5cyIsIk1hdGgiLCJyb3VuZCIsInZhbGlkYXRlVXNlcm5hbWUiLCJnZXRVc2VyUHJldmlldyIsImNvbW1lbnRzRGF0YSIsInVzZXJSZXNwb25zZSIsImV4aXN0cyIsImthcm1hIiwiYWNjb3VudEFnZSIsInJlY2VudEFjdGl2aXR5IiwiZXN0aW1hdGVkQ29tbWVudHMiLCJ1c2VyRGF0YSIsInVzZXIiLCJkYXRhIiwiY29tbWVudHNSZXNwb25zZSIsImhhc1JlY2VudEFjdGl2aXR5IiwiY2hpbGRyZW4iLCJmbG9vciIsImNyZWF0ZWRfdXRjIiwiYWdlU3RyaW5nIiwiZGFpbHlLYXJtYSIsImNvbW1lbnRfa2FybWEiLCJtYXgiLCJtaW4iLCJ0b3RhbF9rYXJtYSIsImNsZWFyVXNlckNhY2hlIiwiY2xlYXJBbmFseXNpcyIsImdldENhY2hlU3RhdHMiLCJnZXRTdGF0cyIsImdldEJ1ZGdldFN0YXRzIiwiYnVkZ2V0IiwidXNhZ2UiLCJnZXRVc2FnZVN0YXRzIiwicmVzZXRCdWRnZXQiLCJzZXRCdWRnZXQiLCJtYXhEb2xsYXIiLCJ3YXJuaW5nVGhyZXNob2xkIiwiZ2V0RGVidWdJbmZvIiwiY2FjaGUiLCJhbmFseXplVXNlclN0cmVhbSIsInN0YWdlIiwicHJvZ3Jlc3MiLCJpc1ZhbGlkIiwicHJldmlldyIsImFuYWx5emVCYXRjaCIsInVzZXJuYW1lcyIsInJlc3VsdHMiLCJwdXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0Q2FjaGVkQW5hbHlzaXMiLCJoZWFsdGhDaGVjayIsInNlcnZpY2VzIiwicmVkZGl0Iiwib3BlbnJvdXRlciIsImhlYWx0aHlTZXJ2aWNlcyIsIk9iamVjdCIsInZhbHVlcyIsImZpbHRlciIsIkJvb2xlYW4iLCJhbmFseXNpc1NlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/analysisService.ts\n"));

/***/ })

});