"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/analysisService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/analysisService.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisService: () => (/* binding */ AnalysisService),\n/* harmony export */   analysisService: () => (/* binding */ analysisService)\n/* harmony export */ });\n/* harmony import */ var _cacheService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cacheService */ \"(app-pages-browser)/./src/lib/services/cacheService.ts\");\n/* harmony import */ var _tokenBudget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenBudget */ \"(app-pages-browser)/./src/lib/services/tokenBudget.ts\");\n\n\nclass AnalysisService {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[AnalysisService]', ...args);\n        }\n    }\n    async analyzeUser(username) {\n        let analyzerUserId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '1';\n        try {\n            var _reportData_contradictions;\n            // Validate username\n            if (!username || username.trim().length === 0) {\n                throw new Error('Username is required');\n            }\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            this.debug(\"Starting analysis for \".concat(cleanUsername, \" via server API\"));\n            // Check budget status\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n            this.debug('Budget status:', budgetStatus);\n            if (budgetStatus.isWarning) {\n                console.warn(\"Budget warning: \".concat(budgetStatus.percentage.toFixed(1), \"% used\"));\n            }\n            // Call server-side API for analysis\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: cleanUsername,\n                    verbose: this.verbose\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({\n                        error: 'Unknown error'\n                    }));\n                throw new Error(errorData.error || \"Analysis failed with status \".concat(response.status));\n            }\n            const reportData = await response.json();\n            // Create analysis result\n            const analysis = {\n                id: \"analysis-\".concat(Date.now(), \"-\").concat(cleanUsername),\n                targetUsername: cleanUsername,\n                analyzerUserId,\n                contradictionsFound: ((_reportData_contradictions = reportData.contradictions) === null || _reportData_contradictions === void 0 ? void 0 : _reportData_contradictions.length) || 0,\n                confidenceScore: this.calculateWeightedConfidence(reportData.contradictions || []),\n                analysisDate: new Date().toISOString(),\n                reportData,\n                status: 'completed'\n            };\n            this.debug(\"Analysis complete for \".concat(cleanUsername, \":\"), {\n                contradictionsFound: analysis.contradictionsFound,\n                weightedConfidence: analysis.confidenceScore,\n                status: analysis.status\n            });\n            return analysis;\n        } catch (error) {\n            this.debug('Analysis failed:', error);\n            // Return failed analysis with error info\n            return {\n                id: \"analysis-failed-\".concat(Date.now()),\n                targetUsername: username,\n                analyzerUserId,\n                contradictionsFound: 0,\n                confidenceScore: 0,\n                analysisDate: new Date().toISOString(),\n                reportData: {\n                    summary: \"Analysis failed: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'),\n                    contradictions: [],\n                    timeline: [],\n                    stats: {\n                        totalComments: 0,\n                        timespan: '0 days',\n                        topSubreddits: [],\n                        sentimentTrend: 0\n                    }\n                },\n                status: 'failed'\n            };\n        }\n    }\n    calculateWeightedConfidence(contradictions) {\n        if (contradictions.length === 0) return 0;\n        // Weight by recency and verification status\n        let totalWeight = 0;\n        let weightedSum = 0;\n        for (const contradiction of contradictions){\n            let weight = 1;\n            // Higher weight for verified contradictions\n            if (contradiction.verified) {\n                weight *= 1.5;\n            }\n            // Higher weight for recent contradictions\n            if (contradiction.dates && contradiction.dates.length >= 2) {\n                const dates = contradiction.dates.map((d)=>new Date(d).getTime());\n                const avgDate = (dates[0] + dates[1]) / 2;\n                const ageInDays = (Date.now() - avgDate) / (24 * 60 * 60 * 1000);\n                if (ageInDays < 30) {\n                    weight *= 1.3; // Recent contradictions are more significant\n                } else if (ageInDays > 365) {\n                    weight *= 0.8; // Older contradictions less significant\n                }\n            }\n            // Weight by confidence score\n            const confidenceScore = contradiction.confidenceScore || 50;\n            weight *= confidenceScore / 100;\n            weightedSum += confidenceScore * weight;\n            totalWeight += weight;\n        }\n        return Math.round(weightedSum / totalWeight);\n    }\n    async validateUsername(username) {\n        try {\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            const response = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            return response.ok;\n        } catch (e) {\n            return false;\n        }\n    }\n    async getUserPreview(username) {\n        try {\n            var _commentsData_data_children, _commentsData_data;\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            // Get user info\n            const userResponse = await fetch(\"https:thoughtpolice.vercel.app/api/reddit/user/\".concat(cleanUsername, \"/about.json\"));\n            console.log('User preview response:', userResponse);\n            if (!userResponse.ok) {\n                return {\n                    exists: false,\n                    karma: 0,\n                    accountAge: 'Unknown',\n                    recentActivity: false,\n                    estimatedComments: 0\n                };\n            }\n            const userData = await userResponse.json();\n            const user = userData.data;\n            // Get a small sample of comments to check for recent activity\n            const commentsResponse = await fetch(\"/api/reddit/user/\".concat(cleanUsername, \"/comments.json?limit=5\"));\n            const commentsData = commentsResponse.ok ? await commentsResponse.json() : null;\n            const hasRecentActivity = (commentsData === null || commentsData === void 0 ? void 0 : (_commentsData_data = commentsData.data) === null || _commentsData_data === void 0 ? void 0 : (_commentsData_data_children = _commentsData_data.children) === null || _commentsData_data_children === void 0 ? void 0 : _commentsData_data_children.length) > 0;\n            const accountAge = Math.floor((Date.now() / 1000 - user.created_utc) / (24 * 60 * 60));\n            const ageString = accountAge < 30 ? \"\".concat(accountAge, \" days\") : accountAge < 365 ? \"\".concat(Math.floor(accountAge / 30), \" months\") : \"\".concat(Math.floor(accountAge / 365), \" years\");\n            // Better estimation based on karma and account age\n            const dailyKarma = user.comment_karma / Math.max(accountAge, 1);\n            const estimatedComments = Math.min(Math.max(dailyKarma * 2, 100), 8000);\n            return {\n                exists: true,\n                karma: user.total_karma || 0,\n                accountAge: ageString,\n                recentActivity: hasRecentActivity,\n                estimatedComments: Math.floor(estimatedComments)\n            };\n        } catch (error) {\n            this.debug('getUserPreview failed:', error);\n            return {\n                exists: false,\n                karma: 0,\n                accountAge: 'Unknown',\n                recentActivity: false,\n                estimatedComments: 0\n            };\n        }\n    }\n    // Enhanced cache management\n    clearUserCache(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.clearAnalysis(cleanUsername);\n    }\n    getCacheStats() {\n        return _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getStats();\n    }\n    getBudgetStats() {\n        return {\n            budget: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus(),\n            usage: _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getUsageStats()\n        };\n    }\n    resetBudget() {\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.resetBudget();\n    }\n    setBudget(maxDollar) {\n        let warningThreshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 80;\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.setBudget({\n            maxDollar,\n            warningThreshold\n        });\n    }\n    // Debug and monitoring methods\n    getDebugInfo() {\n        return {\n            cache: _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getDebugInfo(),\n            budget: this.getBudgetStats(),\n            verbose: this.verbose\n        };\n    }\n    // Streaming analysis for large datasets\n    async *analyzeUserStream(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        yield {\n            stage: 'validation',\n            progress: 0\n        };\n        try {\n            // Validate user\n            const isValid = await this.validateUsername(cleanUsername);\n            if (!isValid) {\n                throw new Error('User not found');\n            }\n            yield {\n                stage: 'validation',\n                progress: 100\n            };\n            // Get user preview\n            yield {\n                stage: 'fetching',\n                progress: 0\n            };\n            const preview = await this.getUserPreview(cleanUsername);\n            yield {\n                stage: 'fetching',\n                progress: 50,\n                data: preview\n            };\n            // Perform analysis\n            yield {\n                stage: 'analyzing',\n                progress: 0\n            };\n            const analysis = await this.analyzeUser(cleanUsername);\n            yield {\n                stage: 'analyzing',\n                progress: 100,\n                data: analysis.reportData\n            };\n            // Complete\n            yield {\n                stage: 'complete',\n                progress: 100,\n                data: analysis.reportData\n            };\n        } catch (error) {\n            yield {\n                stage: 'error',\n                progress: 0,\n                data: {\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                }\n            };\n        }\n    }\n    // Batch analysis for multiple users\n    async analyzeBatch(usernames) {\n        const results = [];\n        for (const username of usernames){\n            try {\n                const analysis = await this.analyzeUser(username);\n                results.push(analysis);\n                // Add delay between analyses to respect rate limits\n                await new Promise((resolve)=>setTimeout(resolve, 2000));\n            } catch (error) {\n                this.debug(\"Batch analysis failed for \".concat(username, \":\"), error);\n            // Continue with other users even if one fails\n            }\n        }\n        return results;\n    }\n    // Get cached analysis if available\n    getCachedAnalysis(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        // This would need to be implemented based on your cache structure\n        // For now, return null to indicate no cached analysis\n        return null;\n    }\n    // Health check for the analysis service\n    async healthCheck() {\n        const services = {\n            reddit: false,\n            openrouter: false,\n            cache: true // Cache is always available locally\n        };\n        // Test Reddit API\n        try {\n            const response = await fetch('/api/reddit/r/test.json', {\n                method: 'HEAD'\n            });\n            services.reddit = response.ok;\n        } catch (e) {\n            services.reddit = false;\n        }\n        // Test OpenRouter (would need a test endpoint)\n        try {\n            const response = await fetch('/api/analyze', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    username: 'test',\n                    healthCheck: true\n                })\n            });\n            services.openrouter = response.status !== 500;\n        } catch (e) {\n            services.openrouter = false;\n        }\n        const budget = this.getBudgetStats();\n        const healthyServices = Object.values(services).filter(Boolean).length;\n        let status;\n        if (healthyServices === 3) {\n            status = 'healthy';\n        } else if (healthyServices >= 2) {\n            status = 'degraded';\n        } else {\n            status = 'unhealthy';\n        }\n        return {\n            status,\n            services,\n            budget\n        };\n    }\n    constructor(){\n        this.verbose = false;\n    }\n}\nconst analysisService = new AnalysisService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvYW5hbHlzaXNTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBOEM7QUFDRjtBQUdyQyxNQUFNRTtJQUdYQyxXQUFXQyxPQUFnQixFQUFFO1FBQzNCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNqQjtJQUVRQyxRQUFzQjtRQUFoQjtZQUFHQyxLQUFILHVCQUFjOztRQUMxQixJQUFJLElBQUksQ0FBQ0YsT0FBTyxFQUFFO1lBQ2hCRyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCRjtRQUN0QztJQUNGO0lBRUEsTUFBTUcsWUFBWUMsUUFBZ0IsRUFBbUQ7WUFBakRDLGlCQUFBQSxpRUFBeUI7UUFDM0QsSUFBSTtnQkF5Q3FCQztZQXhDdkIsb0JBQW9CO1lBQ3BCLElBQUksQ0FBQ0YsWUFBWUEsU0FBU0csSUFBSSxHQUFHQyxNQUFNLEtBQUssR0FBRztnQkFDN0MsTUFBTSxJQUFJQyxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsZ0JBQWdCTixTQUFTRyxJQUFJLEdBQUdJLE9BQU8sQ0FBQyxRQUFRO1lBQ3RELElBQUksQ0FBQ1osS0FBSyxDQUFDLHlCQUF1QyxPQUFkVyxlQUFjO1lBRWxELHNCQUFzQjtZQUN0QixNQUFNRSxlQUFlakIscURBQVdBLENBQUNrQixlQUFlO1lBQ2hELElBQUksQ0FBQ2QsS0FBSyxDQUFDLGtCQUFrQmE7WUFFN0IsSUFBSUEsYUFBYUUsU0FBUyxFQUFFO2dCQUMxQmIsUUFBUWMsSUFBSSxDQUFDLG1CQUFzRCxPQUFuQ0gsYUFBYUksVUFBVSxDQUFDQyxPQUFPLENBQUMsSUFBRztZQUNyRTtZQUVBLG9DQUFvQztZQUNwQyxNQUFNQyxXQUFXLE1BQU1DLE1BQU0sZ0JBQWdCO2dCQUMzQ0MsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQ25CcEIsVUFBVU07b0JBQ1ZaLFNBQVMsSUFBSSxDQUFD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a0I7UUFDbEIsSUFBSTtZQUNGLE1BQU1sRixXQUFXLE1BQU1DLE1BQU0sMkJBQTJCO2dCQUFFQyxRQUFRO1lBQU87WUFDekUrRixTQUFTQyxNQUFNLEdBQUdsRyxTQUFTTyxFQUFFO1FBQy9CLEVBQUUsVUFBTTtZQUNOMEYsU0FBU0MsTUFBTSxHQUFHO1FBQ3BCO1FBRUEsK0NBQStDO1FBQy9DLElBQUk7WUFDRixNQUFNbEcsV0FBVyxNQUFNQyxNQUFNLGdCQUFnQjtnQkFDM0NDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQUUsZ0JBQWdCO2dCQUFtQjtnQkFDOUNDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRXBCLFVBQVU7b0JBQVE4RyxhQUFhO2dCQUFLO1lBQzdEO1lBQ0FDLFNBQVNFLFVBQVUsR0FBR25HLFNBQVNZLE1BQU0sS0FBSztRQUM1QyxFQUFFLFVBQU07WUFDTnFGLFNBQVNFLFVBQVUsR0FBRztRQUN4QjtRQUVBLE1BQU16QixTQUFTLElBQUksQ0FBQ0QsY0FBYztRQUNsQyxNQUFNMkIsa0JBQWtCQyxPQUFPQyxNQUFNLENBQUNMLFVBQVVNLE1BQU0sQ0FBQ0MsU0FBU2xILE1BQU07UUFFdEUsSUFBSXNCO1FBQ0osSUFBSXdGLG9CQUFvQixHQUFHO1lBQ3pCeEYsU0FBUztRQUNYLE9BQU8sSUFBSXdGLG1CQUFtQixHQUFHO1lBQy9CeEYsU0FBUztRQUNYLE9BQU87WUFDTEEsU0FBUztRQUNYO1FBRUEsT0FBTztZQUNMQTtZQUNBcUY7WUFDQXZCO1FBQ0Y7SUFDRjs7YUFyV1E5RixVQUFVOztBQXNXcEI7QUFFTyxNQUFNNkgsa0JBQWtCLElBQUkvSCxrQkFBa0IiLCJzb3VyY2VzIjpbIkQ6XFxjb2RpbmdcXG9wZW4tc291cmNlXFx0aG91Z2h0LXBvbGljZVxcc3JjXFxsaWJcXHNlcnZpY2VzXFxhbmFseXNpc1NlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2FjaGVTZXJ2aWNlIH0gZnJvbSAnLi9jYWNoZVNlcnZpY2UnO1xyXG5pbXBvcnQgeyB0b2tlbkJ1ZGdldCB9IGZyb20gJy4vdG9rZW5CdWRnZXQnO1xyXG5pbXBvcnQgeyBBbmFseXNpcyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBBbmFseXNpc1NlcnZpY2Uge1xyXG4gIHByaXZhdGUgdmVyYm9zZSA9IGZhbHNlO1xyXG5cclxuICBzZXRWZXJib3NlKHZlcmJvc2U6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQW5hbHlzaXNTZXJ2aWNlXScsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVVzZXIodXNlcm5hbWU6IHN0cmluZywgYW5hbHl6ZXJVc2VySWQ6IHN0cmluZyA9ICcxJyk6IFByb21pc2U8QW5hbHlzaXM+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJuYW1lXHJcbiAgICAgIGlmICghdXNlcm5hbWUgfHwgdXNlcm5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlcm5hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgICAgdGhpcy5kZWJ1ZyhgU3RhcnRpbmcgYW5hbHlzaXMgZm9yICR7Y2xlYW5Vc2VybmFtZX0gdmlhIHNlcnZlciBBUElgKTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGJ1ZGdldCBzdGF0dXNcclxuICAgICAgY29uc3QgYnVkZ2V0U3RhdHVzID0gdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCk7XHJcbiAgICAgIHRoaXMuZGVidWcoJ0J1ZGdldCBzdGF0dXM6JywgYnVkZ2V0U3RhdHVzKTtcclxuXHJcbiAgICAgIGlmIChidWRnZXRTdGF0dXMuaXNXYXJuaW5nKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBCdWRnZXQgd2FybmluZzogJHtidWRnZXRTdGF0dXMucGVyY2VudGFnZS50b0ZpeGVkKDEpfSUgdXNlZGApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDYWxsIHNlcnZlci1zaWRlIEFQSSBmb3IgYW5hbHlzaXNcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9hbmFseXplJywge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxyXG4gICAgICAgICAgdXNlcm5hbWU6IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2UgXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoeyBlcnJvcjogJ1Vua25vd24gZXJyb3InIH0pKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBBbmFseXNpcyBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlcG9ydERhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgYW5hbHlzaXMgcmVzdWx0XHJcbiAgICAgIGNvbnN0IGFuYWx5c2lzOiBBbmFseXNpcyA9IHtcclxuICAgICAgICBpZDogYGFuYWx5c2lzLSR7RGF0ZS5ub3coKX0tJHtjbGVhblVzZXJuYW1lfWAsXHJcbiAgICAgICAgdGFyZ2V0VXNlcm5hbWU6IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgYW5hbHl6ZXJVc2VySWQsXHJcbiAgICAgICAgY29udHJhZGljdGlvbnNGb3VuZDogcmVwb3J0RGF0YS5jb250cmFkaWN0aW9ucz8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgICAgY29uZmlkZW5jZVNjb3JlOiB0aGlzLmNhbGN1bGF0ZVdlaWdodGVkQ29uZmlkZW5jZShyZXBvcnREYXRhLmNvbnRyYWRpY3Rpb25zIHx8IFtdKSxcclxuICAgICAgICBhbmFseXNpc0RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICByZXBvcnREYXRhLFxyXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCdcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZGVidWcoYEFuYWx5c2lzIGNvbXBsZXRlIGZvciAke2NsZWFuVXNlcm5hbWV9OmAsIHtcclxuICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiBhbmFseXNpcy5jb250cmFkaWN0aW9uc0ZvdW5kLFxyXG4gICAgICAgIHdlaWdodGVkQ29uZmlkZW5jZTogYW5hbHlzaXMuY29uZmlkZW5jZVNjb3JlLFxyXG4gICAgICAgIHN0YXR1czogYW5hbHlzaXMuc3RhdHVzXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGFuYWx5c2lzO1xyXG5cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuZGVidWcoJ0FuYWx5c2lzIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXR1cm4gZmFpbGVkIGFuYWx5c2lzIHdpdGggZXJyb3IgaW5mb1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBgYW5hbHlzaXMtZmFpbGVkLSR7RGF0ZS5ub3coKX1gLFxyXG4gICAgICAgIHRhcmdldFVzZXJuYW1lOiB1c2VybmFtZSxcclxuICAgICAgICBhbmFseXplclVzZXJJZCxcclxuICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiAwLFxyXG4gICAgICAgIGNvbmZpZGVuY2VTY29yZTogMCxcclxuICAgICAgICBhbmFseXNpc0RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICByZXBvcnREYXRhOiB7XHJcbiAgICAgICAgICBzdW1tYXJ5OiBgQW5hbHlzaXMgZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3Igb2NjdXJyZWQnfWAsXHJcbiAgICAgICAgICBjb250cmFkaWN0aW9uczogW10sXHJcbiAgICAgICAgICB0aW1lbGluZTogW10sXHJcbiAgICAgICAgICBzdGF0czoge1xyXG4gICAgICAgICAgICB0b3RhbENvbW1lbnRzOiAwLFxyXG4gICAgICAgICAgICB0aW1lc3BhbjogJzAgZGF5cycsXHJcbiAgICAgICAgICAgIHRvcFN1YnJlZGRpdHM6IFtdLFxyXG4gICAgICAgICAgICBzZW50aW1lbnRUcmVuZDogMFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RhdHVzOiAnZmFpbGVkJ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVXZWlnaHRlZENvbmZpZGVuY2UoY29udHJhZGljdGlvbnM6IGFueVtdKTogbnVtYmVyIHtcclxuICAgIGlmIChjb250cmFkaWN0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiAwO1xyXG5cclxuICAgIC8vIFdlaWdodCBieSByZWNlbmN5IGFuZCB2ZXJpZmljYXRpb24gc3RhdHVzXHJcbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xyXG4gICAgbGV0IHdlaWdodGVkU3VtID0gMDtcclxuXHJcbiAgICBmb3IgKGNvbnN0IGNvbnRyYWRpY3Rpb24gb2YgY29udHJhZGljdGlvbnMpIHtcclxuICAgICAgbGV0IHdlaWdodCA9IDE7XHJcbiAgICAgIFxyXG4gICAgICAvLyBIaWdoZXIgd2VpZ2h0IGZvciB2ZXJpZmllZCBjb250cmFkaWN0aW9uc1xyXG4gICAgICBpZiAoY29udHJhZGljdGlvbi52ZXJpZmllZCkge1xyXG4gICAgICAgIHdlaWdodCAqPSAxLjU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEhpZ2hlciB3ZWlnaHQgZm9yIHJlY2VudCBjb250cmFkaWN0aW9uc1xyXG4gICAgICBpZiAoY29udHJhZGljdGlvbi5kYXRlcyAmJiBjb250cmFkaWN0aW9uLmRhdGVzLmxlbmd0aCA+PSAyKSB7XHJcbiAgICAgICAgY29uc3QgZGF0ZXMgPSBjb250cmFkaWN0aW9uLmRhdGVzLm1hcCgoZDogc3RyaW5nKSA9PiBuZXcgRGF0ZShkKS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGNvbnN0IGF2Z0RhdGUgPSAoZGF0ZXNbMF0gKyBkYXRlc1sxXSkgLyAyO1xyXG4gICAgICAgIGNvbnN0IGFnZUluRGF5cyA9IChEYXRlLm5vdygpIC0gYXZnRGF0ZSkgLyAoMjQgKiA2MCAqIDYwICogMTAwMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGFnZUluRGF5cyA8IDMwKSB7XHJcbiAgICAgICAgICB3ZWlnaHQgKj0gMS4zOyAvLyBSZWNlbnQgY29udHJhZGljdGlvbnMgYXJlIG1vcmUgc2lnbmlmaWNhbnRcclxuICAgICAgICB9IGVsc2UgaWYgKGFnZUluRGF5cyA+IDM2NSkge1xyXG4gICAgICAgICAgd2VpZ2h0ICo9IDAuODsgLy8gT2xkZXIgY29udHJhZGljdGlvbnMgbGVzcyBzaWduaWZpY2FudFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gV2VpZ2h0IGJ5IGNvbmZpZGVuY2Ugc2NvcmVcclxuICAgICAgY29uc3QgY29uZmlkZW5jZVNjb3JlID0gY29udHJhZGljdGlvbi5jb25maWRlbmNlU2NvcmUgfHwgNTA7XHJcbiAgICAgIHdlaWdodCAqPSAoY29uZmlkZW5jZVNjb3JlIC8gMTAwKTtcclxuICAgICAgXHJcbiAgICAgIHdlaWdodGVkU3VtICs9IGNvbmZpZGVuY2VTY29yZSAqIHdlaWdodDtcclxuICAgICAgdG90YWxXZWlnaHQgKz0gd2VpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLnJvdW5kKHdlaWdodGVkU3VtIC8gdG90YWxXZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdmFsaWRhdGVVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3JlZGRpdC91c2VyLyR7Y2xlYW5Vc2VybmFtZX0vYWJvdXQuanNvbmApO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0VXNlclByZXZpZXcodXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8e1xyXG4gICAgZXhpc3RzOiBib29sZWFuO1xyXG4gICAga2FybWE6IG51bWJlcjtcclxuICAgIGFjY291bnRBZ2U6IHN0cmluZztcclxuICAgIHJlY2VudEFjdGl2aXR5OiBib29sZWFuO1xyXG4gICAgZXN0aW1hdGVkQ29tbWVudHM6IG51bWJlcjtcclxuICB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHVzZXIgaW5mb1xyXG4gICAgICBjb25zdCB1c2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6dGhvdWdodHBvbGljZS52ZXJjZWwuYXBwL2FwaS9yZWRkaXQvdXNlci8ke2NsZWFuVXNlcm5hbWV9L2Fib3V0Lmpzb25gKTtcclxuICAgICAgY29uc29sZS5sb2coJ1VzZXIgcHJldmlldyByZXNwb25zZTonLCB1c2VyUmVzcG9uc2UpO1xyXG4gICAgICBpZiAoIXVzZXJSZXNwb25zZS5vaykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBleGlzdHM6IGZhbHNlLFxyXG4gICAgICAgICAga2FybWE6IDAsXHJcbiAgICAgICAgICBhY2NvdW50QWdlOiAnVW5rbm93bicsXHJcbiAgICAgICAgICByZWNlbnRBY3Rpdml0eTogZmFsc2UsXHJcbiAgICAgICAgICBlc3RpbWF0ZWRDb21tZW50czogMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgdXNlclJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY29uc3QgdXNlciA9IHVzZXJEYXRhLmRhdGE7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgYSBzbWFsbCBzYW1wbGUgb2YgY29tbWVudHMgdG8gY2hlY2sgZm9yIHJlY2VudCBhY3Rpdml0eVxyXG4gICAgICBjb25zdCBjb21tZW50c1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcmVkZGl0L3VzZXIvJHtjbGVhblVzZXJuYW1lfS9jb21tZW50cy5qc29uP2xpbWl0PTVgKTtcclxuICAgICAgY29uc3QgY29tbWVudHNEYXRhID0gY29tbWVudHNSZXNwb25zZS5vayA/IGF3YWl0IGNvbW1lbnRzUmVzcG9uc2UuanNvbigpIDogbnVsbDtcclxuICAgICAgY29uc3QgaGFzUmVjZW50QWN0aXZpdHkgPSBjb21tZW50c0RhdGE/LmRhdGE/LmNoaWxkcmVuPy5sZW5ndGggPiAwO1xyXG5cclxuICAgICAgY29uc3QgYWNjb3VudEFnZSA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgLyAxMDAwIC0gdXNlci5jcmVhdGVkX3V0YykgLyAoMjQgKiA2MCAqIDYwKSk7XHJcbiAgICAgIGNvbnN0IGFnZVN0cmluZyA9IGFjY291bnRBZ2UgPCAzMCA/IGAke2FjY291bnRBZ2V9IGRheXNgIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudEFnZSA8IDM2NSA/IGAke01hdGguZmxvb3IoYWNjb3VudEFnZSAvIDMwKX0gbW9udGhzYCA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIGAke01hdGguZmxvb3IoYWNjb3VudEFnZSAvIDM2NSl9IHllYXJzYDtcclxuXHJcbiAgICAgIC8vIEJldHRlciBlc3RpbWF0aW9uIGJhc2VkIG9uIGthcm1hIGFuZCBhY2NvdW50IGFnZVxyXG4gICAgICBjb25zdCBkYWlseUthcm1hID0gdXNlci5jb21tZW50X2thcm1hIC8gTWF0aC5tYXgoYWNjb3VudEFnZSwgMSk7XHJcbiAgICAgIGNvbnN0IGVzdGltYXRlZENvbW1lbnRzID0gTWF0aC5taW4oTWF0aC5tYXgoZGFpbHlLYXJtYSAqIDIsIDEwMCksIDgwMDApO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBleGlzdHM6IHRydWUsXHJcbiAgICAgICAga2FybWE6IHVzZXIudG90YWxfa2FybWEgfHwgMCxcclxuICAgICAgICBhY2NvdW50QWdlOiBhZ2VTdHJpbmcsXHJcbiAgICAgICAgcmVjZW50QWN0aXZpdHk6IGhhc1JlY2VudEFjdGl2aXR5LFxyXG4gICAgICAgIGVzdGltYXRlZENvbW1lbnRzOiBNYXRoLmZsb29yKGVzdGltYXRlZENvbW1lbnRzKVxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5kZWJ1ZygnZ2V0VXNlclByZXZpZXcgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBleGlzdHM6IGZhbHNlLFxyXG4gICAgICAgIGthcm1hOiAwLFxyXG4gICAgICAgIGFjY291bnRBZ2U6ICdVbmtub3duJyxcclxuICAgICAgICByZWNlbnRBY3Rpdml0eTogZmFsc2UsXHJcbiAgICAgICAgZXN0aW1hdGVkQ29tbWVudHM6IDBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEVuaGFuY2VkIGNhY2hlIG1hbmFnZW1lbnRcclxuICBjbGVhclVzZXJDYWNoZSh1c2VybmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgY2FjaGVTZXJ2aWNlLmNsZWFyQW5hbHlzaXMoY2xlYW5Vc2VybmFtZSk7XHJcbiAgfVxyXG5cclxuICBnZXRDYWNoZVN0YXRzKCkge1xyXG4gICAgcmV0dXJuIGNhY2hlU2VydmljZS5nZXRTdGF0cygpO1xyXG4gIH1cclxuXHJcbiAgZ2V0QnVkZ2V0U3RhdHMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBidWRnZXQ6IHRva2VuQnVkZ2V0LmdldEJ1ZGdldFN0YXR1cygpLFxyXG4gICAgICB1c2FnZTogdG9rZW5CdWRnZXQuZ2V0VXNhZ2VTdGF0cygpXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmVzZXRCdWRnZXQoKTogdm9pZCB7XHJcbiAgICB0b2tlbkJ1ZGdldC5yZXNldEJ1ZGdldCgpO1xyXG4gIH1cclxuXHJcbiAgc2V0QnVkZ2V0KG1heERvbGxhcjogbnVtYmVyLCB3YXJuaW5nVGhyZXNob2xkOiBudW1iZXIgPSA4MCk6IHZvaWQge1xyXG4gICAgdG9rZW5CdWRnZXQuc2V0QnVkZ2V0KHsgbWF4RG9sbGFyLCB3YXJuaW5nVGhyZXNob2xkIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gRGVidWcgYW5kIG1vbml0b3JpbmcgbWV0aG9kc1xyXG4gIGdldERlYnVnSW5mbygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNhY2hlOiBjYWNoZVNlcnZpY2UuZ2V0RGVidWdJbmZvKCksXHJcbiAgICAgIGJ1ZGdldDogdGhpcy5nZXRCdWRnZXRTdGF0cygpLFxyXG4gICAgICB2ZXJib3NlOiB0aGlzLnZlcmJvc2VcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBTdHJlYW1pbmcgYW5hbHlzaXMgZm9yIGxhcmdlIGRhdGFzZXRzXHJcbiAgYXN5bmMqIGFuYWx5emVVc2VyU3RyZWFtKHVzZXJuYW1lOiBzdHJpbmcpOiBBc3luY0dlbmVyYXRvcjx7XHJcbiAgICBzdGFnZTogc3RyaW5nO1xyXG4gICAgcHJvZ3Jlc3M6IG51bWJlcjtcclxuICAgIGRhdGE/OiBhbnk7XHJcbiAgfSwgdm9pZCwgdW5rbm93bj4ge1xyXG4gICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgIFxyXG4gICAgeWllbGQgeyBzdGFnZTogJ3ZhbGlkYXRpb24nLCBwcm9ncmVzczogMCB9O1xyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBWYWxpZGF0ZSB1c2VyXHJcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBhd2FpdCB0aGlzLnZhbGlkYXRlVXNlcm5hbWUoY2xlYW5Vc2VybmFtZSk7XHJcbiAgICAgIGlmICghaXNWYWxpZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlciBub3QgZm91bmQnKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ3ZhbGlkYXRpb24nLCBwcm9ncmVzczogMTAwIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdXNlciBwcmV2aWV3XHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdmZXRjaGluZycsIHByb2dyZXNzOiAwIH07XHJcbiAgICAgIGNvbnN0IHByZXZpZXcgPSBhd2FpdCB0aGlzLmdldFVzZXJQcmV2aWV3KGNsZWFuVXNlcm5hbWUpO1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnZmV0Y2hpbmcnLCBwcm9ncmVzczogNTAsIGRhdGE6IHByZXZpZXcgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIFBlcmZvcm0gYW5hbHlzaXNcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2FuYWx5emluZycsIHByb2dyZXNzOiAwIH07XHJcbiAgICAgIGNvbnN0IGFuYWx5c2lzID0gYXdhaXQgdGhpcy5hbmFseXplVXNlcihjbGVhblVzZXJuYW1lKTtcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2FuYWx5emluZycsIHByb2dyZXNzOiAxMDAsIGRhdGE6IGFuYWx5c2lzLnJlcG9ydERhdGEgfTtcclxuICAgICAgXHJcbiAgICAgIC8vIENvbXBsZXRlXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdjb21wbGV0ZScsIHByb2dyZXNzOiAxMDAsIGRhdGE6IGFuYWx5c2lzLnJlcG9ydERhdGEgfTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnZXJyb3InLCBwcm9ncmVzczogMCwgZGF0YTogeyBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicgfSB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQmF0Y2ggYW5hbHlzaXMgZm9yIG11bHRpcGxlIHVzZXJzXHJcbiAgYXN5bmMgYW5hbHl6ZUJhdGNoKHVzZXJuYW1lczogc3RyaW5nW10pOiBQcm9taXNlPEFuYWx5c2lzW10+IHtcclxuICAgIGNvbnN0IHJlc3VsdHM6IEFuYWx5c2lzW10gPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCB1c2VybmFtZSBvZiB1c2VybmFtZXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBhbmFseXNpcyA9IGF3YWl0IHRoaXMuYW5hbHl6ZVVzZXIodXNlcm5hbWUpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChhbmFseXNpcyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIGRlbGF5IGJldHdlZW4gYW5hbHlzZXMgdG8gcmVzcGVjdCByYXRlIGxpbWl0c1xyXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDAwKSk7XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQmF0Y2ggYW5hbHlzaXMgZmFpbGVkIGZvciAke3VzZXJuYW1lfTpgLCBlcnJvcik7XHJcbiAgICAgICAgLy8gQ29udGludWUgd2l0aCBvdGhlciB1c2VycyBldmVuIGlmIG9uZSBmYWlsc1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH1cclxuXHJcbiAgLy8gR2V0IGNhY2hlZCBhbmFseXNpcyBpZiBhdmFpbGFibGVcclxuICBnZXRDYWNoZWRBbmFseXNpcyh1c2VybmFtZTogc3RyaW5nKTogQW5hbHlzaXMgfCBudWxsIHtcclxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICBcclxuICAgIC8vIFRoaXMgd291bGQgbmVlZCB0byBiZSBpbXBsZW1lbnRlZCBiYXNlZCBvbiB5b3VyIGNhY2hlIHN0cnVjdHVyZVxyXG4gICAgLy8gRm9yIG5vdywgcmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2FjaGVkIGFuYWx5c2lzXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8vIEhlYWx0aCBjaGVjayBmb3IgdGhlIGFuYWx5c2lzIHNlcnZpY2VcclxuICBhc3luYyBoZWFsdGhDaGVjaygpOiBQcm9taXNlPHtcclxuICAgIHN0YXR1czogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknO1xyXG4gICAgc2VydmljZXM6IHtcclxuICAgICAgcmVkZGl0OiBib29sZWFuO1xyXG4gICAgICBvcGVucm91dGVyOiBib29sZWFuO1xyXG4gICAgICBjYWNoZTogYm9vbGVhbjtcclxuICAgIH07XHJcbiAgICBidWRnZXQ6IGFueTtcclxuICB9PiB7XHJcbiAgICBjb25zdCBzZXJ2aWNlcyA9IHtcclxuICAgICAgcmVkZGl0OiBmYWxzZSxcclxuICAgICAgb3BlbnJvdXRlcjogZmFsc2UsXHJcbiAgICAgIGNhY2hlOiB0cnVlIC8vIENhY2hlIGlzIGFsd2F5cyBhdmFpbGFibGUgbG9jYWxseVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBUZXN0IFJlZGRpdCBBUElcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcmVkZGl0L3IvdGVzdC5qc29uJywgeyBtZXRob2Q6ICdIRUFEJyB9KTtcclxuICAgICAgc2VydmljZXMucmVkZGl0ID0gcmVzcG9uc2Uub2s7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgc2VydmljZXMucmVkZGl0ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVzdCBPcGVuUm91dGVyICh3b3VsZCBuZWVkIGEgdGVzdCBlbmRwb2ludClcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYW5hbHl6ZScsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJuYW1lOiAndGVzdCcsIGhlYWx0aENoZWNrOiB0cnVlIH0pXHJcbiAgICAgIH0pO1xyXG4gICAgICBzZXJ2aWNlcy5vcGVucm91dGVyID0gcmVzcG9uc2Uuc3RhdHVzICE9PSA1MDA7XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgc2VydmljZXMub3BlbnJvdXRlciA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGJ1ZGdldCA9IHRoaXMuZ2V0QnVkZ2V0U3RhdHMoKTtcclxuICAgIGNvbnN0IGhlYWx0aHlTZXJ2aWNlcyA9IE9iamVjdC52YWx1ZXMoc2VydmljZXMpLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XHJcbiAgICBcclxuICAgIGxldCBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5JztcclxuICAgIGlmIChoZWFsdGh5U2VydmljZXMgPT09IDMpIHtcclxuICAgICAgc3RhdHVzID0gJ2hlYWx0aHknO1xyXG4gICAgfSBlbHNlIGlmIChoZWFsdGh5U2VydmljZXMgPj0gMikge1xyXG4gICAgICBzdGF0dXMgPSAnZGVncmFkZWQnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhdHVzID0gJ3VuaGVhbHRoeSc7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzLFxyXG4gICAgICBzZXJ2aWNlcyxcclxuICAgICAgYnVkZ2V0XHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFuYWx5c2lzU2VydmljZSA9IG5ldyBBbmFseXNpc1NlcnZpY2UoKTsiXSwibmFtZXMiOlsiY2FjaGVTZXJ2aWNlIiwidG9rZW5CdWRnZXQiLCJBbmFseXNpc1NlcnZpY2UiLCJzZXRWZXJib3NlIiwidmVyYm9zZSIsImRlYnVnIiwiYXJncyIsImNvbnNvbGUiLCJsb2ciLCJhbmFseXplVXNlciIsInVzZXJuYW1lIiwiYW5hbHl6ZXJVc2VySWQiLCJyZXBvcnREYXRhIiwidHJpbSIsImxlbmd0aCIsIkVycm9yIiwiY2xlYW5Vc2VybmFtZSIsInJlcGxhY2UiLCJidWRnZXRTdGF0dXMiLCJnZXRCdWRnZXRTdGF0dXMiLCJpc1dhcm5pbmciLCJ3YXJuIiwicGVyY2VudGFnZSIsInRvRml4ZWQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJlcnJvciIsInN0YXR1cyIsImFuYWx5c2lzIiwiaWQiLCJEYXRlIiwibm93IiwidGFyZ2V0VXNlcm5hbWUiLCJjb250cmFkaWN0aW9uc0ZvdW5kIiwiY29udHJhZGljdGlvbnMiLCJjb25maWRlbmNlU2NvcmUiLCJjYWxjdWxhdGVXZWlnaHRlZENvbmZpZGVuY2UiLCJhbmFseXNpc0RhdGUiLCJ0b0lTT1N0cmluZyIsIndlaWdodGVkQ29uZmlkZW5jZSIsInN1bW1hcnkiLCJtZXNzYWdlIiwidGltZWxpbmUiLCJzdGF0cyIsInRvdGFsQ29tbWVudHMiLCJ0aW1lc3BhbiIsInRvcFN1YnJlZGRpdHMiLCJzZW50aW1lbnRUcmVuZCIsInRvdGFsV2VpZ2h0Iiwid2VpZ2h0ZWRTdW0iLCJjb250cmFkaWN0aW9uIiwid2VpZ2h0IiwidmVyaWZpZWQiLCJkYXRlcyIsIm1hcCIsImQiLCJnZXRUaW1lIiwiYXZnRGF0ZSIsImFnZUluRGF5cyIsIk1hdGgiLCJyb3VuZCIsInZhbGlkYXRlVXNlcm5hbWUiLCJnZXRVc2VyUHJldmlldyIsImNvbW1lbnRzRGF0YSIsInVzZXJSZXNwb25zZSIsImV4aXN0cyIsImthcm1hIiwiYWNjb3VudEFnZSIsInJlY2VudEFjdGl2aXR5IiwiZXN0aW1hdGVkQ29tbWVudHMiLCJ1c2VyRGF0YSIsInVzZXIiLCJkYXRhIiwiY29tbWVudHNSZXNwb25zZSIsImhhc1JlY2VudEFjdGl2aXR5IiwiY2hpbGRyZW4iLCJmbG9vciIsImNyZWF0ZWRfdXRjIiwiYWdlU3RyaW5nIiwiZGFpbHlLYXJtYSIsImNvbW1lbnRfa2FybWEiLCJtYXgiLCJtaW4iLCJ0b3RhbF9rYXJtYSIsImNsZWFyVXNlckNhY2hlIiwiY2xlYXJBbmFseXNpcyIsImdldENhY2hlU3RhdHMiLCJnZXRTdGF0cyIsImdldEJ1ZGdldFN0YXRzIiwiYnVkZ2V0IiwidXNhZ2UiLCJnZXRVc2FnZVN0YXRzIiwicmVzZXRCdWRnZXQiLCJzZXRCdWRnZXQiLCJtYXhEb2xsYXIiLCJ3YXJuaW5nVGhyZXNob2xkIiwiZ2V0RGVidWdJbmZvIiwiY2FjaGUiLCJhbmFseXplVXNlclN0cmVhbSIsInN0YWdlIiwicHJvZ3Jlc3MiLCJpc1ZhbGlkIiwicHJldmlldyIsImFuYWx5emVCYXRjaCIsInVzZXJuYW1lcyIsInJlc3VsdHMiLCJwdXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiZ2V0Q2FjaGVkQW5hbHlzaXMiLCJoZWFsdGhDaGVjayIsInNlcnZpY2VzIiwicmVkZGl0Iiwib3BlbnJvdXRlciIsImhlYWx0aHlTZXJ2aWNlcyIsIk9iamVjdCIsInZhbHVlcyIsImZpbHRlciIsIkJvb2xlYW4iLCJhbmFseXNpc1NlcnZpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/analysisService.ts\n"));

/***/ })

});